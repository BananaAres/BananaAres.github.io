<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记一次连接云服务器MySQL数据库时总是空闲连接超时断开问题</title>
    <url>/2022/03/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E6%80%BB%E6%98%AF%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E6%96%AD%E5%BC%80%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>​    最新在写项目的时候使用了hikari连接池，连接的是阿里云服务器上部署的MySQL数据库，结果每次运行项目后没操作一小会，就开始报一些警告，具体如下</p>
<p>![image-20220321210958448](/Users/sundaohan/Library/Application Support/typora-user-images/image-20220321210958448.png)</p>
<p>​    The last packet successfully received from the server was 1,209,470 milliseconds ago.  The last packet sent successfully to the server was 5,005 milliseconds ago.). Possibly consider using a shorter maxLifetime value.</p>
<p>还有</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220321211209136.png" alt="image-20220321211209136"></p>
<p> DateHikariCP - Thread starvation or clock leap detected (housekeeper delta=5m11s731ms).</p>
<p>然后连接就断开，无法访问数据库了。</p>
<h1 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h1><p>​    上面的问题总而言之意思就是，连接存活时间超时了之类的，但是数据库中的设置和我的连接池设置的空闲存活时间跟最大存活时间都远大于空闲时间，所以按理说不应该出现这种情况，而换到我本地的数据库，配置完全相同也不会出现这种情况，根据网上说的一些方法修改也不成功。</p>
<p>​    再查了查，发现应该是因为云服务器的Linux系统上的安全设置问题，如果在一段时间内没有与服务器进行交互就会断开连接，包括在用ssh连接云服务器时，如果一段时间不操作，也会卡死只能重连，所以只要是在本地的，就不会出现这种情况。</p>
]]></content>
      <categories>
        <category>【问题】</category>
      </categories>
      <tags>
        <tag>【Java】</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+Bcos智能合约的部署与调用</title>
    <url>/2022/01/18/springboot-Bcos%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="springboot-Bcos智能合约的部署与调用"><a href="#springboot-Bcos智能合约的部署与调用" class="headerlink" title="springboot+Bcos智能合约的部署与调用"></a>springboot+Bcos智能合约的部署与调用</h1><h2 id="一、引入java-sdk"><a href="#一、引入java-sdk" class="headerlink" title="一、引入java sdk"></a>一、引入java sdk</h2><p>​    引入java sdk官方文档说的比较清晰，根据<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/sdk/java_sdk/quick_start.html的步骤引入即可" target="_blank" rel="noopener">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/sdk/java_sdk/quick_start.html的步骤引入即可</a></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220118234529172.png" alt="image-20220118234529172"></p>
<h2 id="二、配置BCOS网络并在JAVA上连接"><a href="#二、配置BCOS网络并在JAVA上连接" class="headerlink" title="二、配置BCOS网络并在JAVA上连接"></a>二、配置BCOS网络并在JAVA上连接</h2><p>1.首先进入bcos目录下的console/conf，比如我的目录是 ~/fisco/console/conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/fisco/console/conf</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220118234755137.png" alt="image-20220118234755137"></p>
<p>修改其中的config.toml文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi config.toml</span><br></pre></td></tr></table></figure>

<p>找到[network]，将其中的127.0.0.1:20200和另一个 修改为本机ip地址，由于我是在虚拟机上，ip地址是192.168.33.11，所以修改如下</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220118234930547.png" alt="image-20220118234930547"></p>
<p>2.进入~/fisco/nodes/127.0.0.1/sdk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/fisco/nodes/127.0.0.1/sdk</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220118235304162.png" alt="image-20220118235304162"></p>
<p>将四个文件复制到项目的main下的resources/conf文件夹下（自己创建一个conf）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220118235331242.png" alt="image-20220118235331242"></p>
<p>之后配置bcos的配置文件，官网上提供了基于spring和springboot的配置方案，但是我测试之后发现在后续的配置中都很麻烦，并且都没有跑通，所以还是选用最简单的xml配置方案，也很方便。</p>
<p>在项目的main/resources下创建applicationContext.xml文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220118235839564.png" alt="image-20220118235839564"></p>
<p>其完整内容如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"defaultConfigProperty"</span> <span class="attr">class</span>=<span class="string">"org.fisco.bcos.sdk.config.model.ConfigProperty"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cryptoMaterial"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"certPath"</span> <span class="attr">value</span>=<span class="string">"conf"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"network"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"peers"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.33.11:20200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.33.11:20201<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"keyStoreDir"</span> <span class="attr">value</span>=<span class="string">"account"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"accountAddress"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"accountFileFormat"</span> <span class="attr">value</span>=<span class="string">"pem"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"accountFilePath"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"threadPool"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"channelProcessorThreadSize"</span> <span class="attr">value</span>=<span class="string">"16"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"receiptProcessorThreadSize"</span> <span class="attr">value</span>=<span class="string">"16"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"maxBlockingQueueSize"</span> <span class="attr">value</span>=<span class="string">"102400"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"defaultConfigOption"</span> <span class="attr">class</span>=<span class="string">"org.fisco.bcos.sdk.config.ConfigOption"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"configProperty"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"defaultConfigProperty"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bcosSDK"</span> <span class="attr">class</span>=<span class="string">"org.fisco.bcos.sdk.BcosSDK"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"configOption"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"defaultConfigOption"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中peers配置中的节点ip地址和端口要和上面配置的相同</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"peers"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.33.11:20200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.33.11:20201<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、编写智能合约并在项目中部署"><a href="#三、编写智能合约并在项目中部署" class="headerlink" title="三、编写智能合约并在项目中部署"></a>三、编写智能合约并在项目中部署</h2><p>1.bcos支持solidity，所以用remix开发即可</p>
<p><a href="https://ethereum.github.io/browser-solidity/#optimize=false&amp;version=soljson-v0.7.1+commit.f4a555be.js" target="_blank" rel="noopener">https://ethereum.github.io/browser-solidity/#optimize=false&amp;version=soljson-v0.7.1+commit.f4a555be.js</a></p>
<p>这里使用自带的HelloWorld.sol演示，这个文件在~/fisco/console/contracts/solidity</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119154309514.png" alt="image-20220119154309514"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.2</span>;</span><br><span class="line"></span><br><span class="line">contract HelloWorld&#123;</span><br><span class="line">    string name;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="function">function <span class="title">set</span><span class="params">(string n)</span></span>&#123;</span><br><span class="line">		<span class="function">emit <span class="title">test</span><span class="params">(n)</span></span>;</span><br><span class="line">    	name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function">event <span class="title">test</span><span class="params">(string a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">       name = <span class="string">"Hello, World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">get</span><span class="params">()</span>constant <span class="title">returns</span><span class="params">(string)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个不涉及到表，实际上bcos的智能合约支持表结构存储，具体可以看官方文档<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/smart_contract.html#kvtable" target="_blank" rel="noopener">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/smart_contract.html#kvtable</a></p>
<p>​    需要注意的是，BCOS和mysql等不同的是表设置的主键是可以重复的，而且无论是增删改查，都需要传入主键值作为参数，而且不提供全表查询功能，所以如果需要全表查询，建议主键值可以设置一个全部都相同的，方便查询。</p>
<p>​    比如设计一个表是</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">number</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张三</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">李四</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">王五</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">赵六</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>​    如果把name当做主键，搜索时只能使用 table.select(name, table.newCondition());这里的name不是主键列名，而是张三、李四、王五这些名字，此时就无法做到全表查询。</p>
<p>​    如果按下面这个设计表</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th>number</th>
</tr>
</thead>
<tbody><tr>
<td align="center">school</td>
<td align="center">张三</td>
<td>1</td>
</tr>
<tr>
<td align="center">school</td>
<td align="center">李四</td>
<td>2</td>
</tr>
<tr>
<td align="center">school</td>
<td align="center">王五</td>
<td>3</td>
</tr>
<tr>
<td align="center">school</td>
<td align="center">赵六</td>
<td>4</td>
</tr>
</tbody></table>
<p>查询时可以直接 table.select(“school”, table.newCondition()); 这样查询的就是全部数据了</p>
<p>2.通过bcos自带的脚本将sol文件转化为java文件</p>
<p>进入console目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/fisco/console</span><br></pre></td></tr></table></figure>

<p>调用下面的start.sh脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sol2java.sh org.example.demo.contract</span><br></pre></td></tr></table></figure>

<p>这个org.example.demo.contract是你在项目中存放智能合约的包，按实际需求写</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119190718900.png" alt="image-20220119190718900"></p>
<p>之后我们进入contracts/sdk/java/org/example/demo/contract</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd contracts&#x2F;sdk&#x2F;java&#x2F;org&#x2F;example&#x2F;demo&#x2F;contract</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119190950075.png" alt="image-20220119190950075"></p>
<p>可以看到HelloWorld.java文件，将其下载到本机上（sz可以百度一下安装和使用方法，这里不赘述）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sz HelloWorld.java</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119191058722.png" alt="image-20220119191058722"></p>
<p>将其放到项目中的contract目录下</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119191205021.png" alt="image-20220119191205021"></p>
<p>3.接着我们在demo包下创建一个conf目录，在其下创建SdkBeanConfig类，用来配置连接区块链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.BcosSDK;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.client.Client;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SdkBeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BcosSDK bcosSDK;</span><br><span class="line">    <span class="keyword">private</span> Client client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContractConfig contractConfig;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//指定配置xml文件的位置</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        bcosSDK = context.getBean(BcosSDK<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//选择群组1</span></span><br><span class="line">        client = bcosSDK.getClient(Integer.valueOf(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//连接后返回当前区块高度</span></span><br><span class="line">        BigInteger blockNumber = client.getBlockNumber().getBlockNumber();</span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        System.out.println(blockNumber);</span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4.之后同级目录创建ContractConfig类，来记录智能合约地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContractConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String HelloWorldAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（文件位置别创建错了）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119192657296.png" alt="image-20220119192657296"></p>
<p>5.创建一个controller类，方便后续的测试</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119192805193.png" alt="image-20220119192805193"></p>
<p>内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.demo.service.HelloWorldService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> HelloWorldService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"set"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(@RequestParam(<span class="string">"n"</span>)</span> String n) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"n = "</span> + n);</span><br><span class="line">        <span class="keyword">return</span> service.set(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.之后再创建一个HelloWorldService类，来实现对智能合约方法的调用</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119193942023.png" alt="image-20220119193942023"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.example.demo.config.ContractConfig;</span><br><span class="line"><span class="keyword">import</span> org.example.demo.contract.HelloWorld;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.client.Client;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.model.TransactionReceipt;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.transaction.manager.AssembleTransactionProcessor;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.transaction.manager.TransactionProcessorFactory;</span><br><span class="line"><span class="keyword">import</span> org.fisco.bcos.sdk.transaction.model.exception.ContractException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> Client client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> ContractConfig contractConfig;</span><br><span class="line"></span><br><span class="line">    AssembleTransactionProcessor txProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloWorld helloWorld;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="comment">//项目部署时运行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.txProcessor =</span><br><span class="line">                TransactionProcessorFactory.createAssembleTransactionProcessor(</span><br><span class="line">                        <span class="keyword">this</span>.client, <span class="keyword">this</span>.client.getCryptoSuite().getCryptoKeyPair());</span><br><span class="line">        <span class="comment">//判断在智能合约配置类里，该智能合约是否已经有地址</span></span><br><span class="line">        <span class="keyword">if</span>(contractConfig.getHelloWorldAddress() == <span class="keyword">null</span> ||</span><br><span class="line">                contractConfig.getHelloWorldAddress().isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果没有的话，将其部署到链上</span></span><br><span class="line">            helloWorld = HelloWorld.deploy(client,client.getCryptoSuite().getCryptoKeyPair());</span><br><span class="line">            System.out.println(<span class="string">"address = "</span> + helloWorld.getContractAddress());</span><br><span class="line">            <span class="comment">//将该合约的地址填写到智能合约配置类中</span></span><br><span class="line">            contractConfig.setHelloWorldAddress(helloWorld.getContractAddress());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果已有地址，则加载</span></span><br><span class="line">            helloWorld = HelloWorld.load(</span><br><span class="line">                    contractConfig.getHelloWorldAddress(),</span><br><span class="line">                    client,</span><br><span class="line">                    client.getCryptoSuite().getCryptoKeyPair()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TransactionReceipt set = helloWorld.set(n);</span><br><span class="line">        <span class="keyword">return</span> set.getBlockNumber();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String mess = helloWorld.get();</span><br><span class="line">        <span class="keyword">return</span> mess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.全部写好后，我们开始测试结果</p>
<p>启动项目后，我们可以看到当前部署后的智能合约地址0x192e21b94ba64a2254380d387dfa40e25b464ed0</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119200045966.png" alt="image-20220119200045966"></p>
<p>打开浏览器，输入localhost:8080/hello/get，可以正确得到返回值</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119200213722.png" alt="image-20220119200213722"></p>
<p>再输入localhost:8080/hello/set?n=testContract，返回了十六进制的高度</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119200531145.png" alt="image-20220119200531145"></p>
<p>再次输入localhost:8080/hello/get，发现修改成功</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119200657383.png" alt="image-20220119200657383"></p>
<p>现在重新运行一下项目</p>
<p>可以看到控制台的智能合约地址已经变成了 0xd8c64830531cafe67125d41dda90efc03fa17ea7</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119200739742.png" alt="image-20220119200739742"></p>
<p>我们打开浏览器，输入localhost:8080/hello/get，发现返回值复原了，证明确实是又重新部署了智能合约</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119200856474.png" alt="image-20220119200856474"></p>
<p>现在我们进入ContractConfig类中，把第一次的智能合约地址赋给HelloWorldAddress</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119201006847.png" alt="image-20220119201006847"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> sundaohan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.neu.config.bcos</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span> ContractConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/18 下午9:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContractConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String HelloWorldAddress = <span class="string">"0x192e21b94ba64a2254380d387dfa40e25b464ed0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次启动项目后，打开浏览器，输入localhost:8080/hello/get，发现返回值是我们当时修改的testContract，证明这次加载的是我们当时部署的那个合约</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220119201121089.png" alt="image-20220119201121089"></p>
<p>至此，BCOS智能合约在springboot框架下的java项目中的部署与调用演示完毕。</p>
]]></content>
      <categories>
        <category>【BCOS】</category>
      </categories>
      <tags>
        <tag>【区块链】</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA+gitee协作式编程</title>
    <url>/2022/01/16/IDEA-gitee%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="IDEA-gitee协作式编程"><a href="#IDEA-gitee协作式编程" class="headerlink" title="IDEA+gitee协作式编程"></a>IDEA+gitee协作式编程</h1><h2 id="一、git下载"><a href="#一、git下载" class="headerlink" title="一、git下载"></a>一、git下载</h2><p>略</p>
<h2 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h2><p>1.登录gitee，点击右上角加号，点击新建仓库</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116173139107.png" alt="image-20220116173139107"></p>
<p>2.根据提示构建自己所需的仓库</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116173332064.png" alt="image-20220116173332064"></p>
<p>3.之后可以看到官方提供的操作提示，可以按步骤进行</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116173450613.png" alt="image-20220116173450613"></p>
<p>创建仓库步骤可以自己进行，在自己想放本地仓库的位置，新建一个文件，文件名和远程仓库名保持一致，此处为test</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116173636036.png" alt="image-20220116173636036"></p>
<p>在终端上 进入这个文件夹，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116173721700.png" alt="image-20220116173721700"></p>
<p>继续输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch README.md</span><br></pre></td></tr></table></figure>

<p>创建一个README.md文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116173902095.png" alt="image-20220116173902095"></p>
<p>输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>将刚才更新的文件提交到本地缓冲区</p>
<p>此时可以输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>查看是否成功</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116174004343.png" alt="image-20220116174004343"></p>
<p>如图所示，有一行绿色的new file，证明成功了</p>
<p>接着输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'fisrt test'</span><br></pre></td></tr></table></figure>

<p>将修改提交到当前的本地库中</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116174314336.png" alt="image-20220116174314336"></p>
<p>之后输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://gitee.com/BananaAres/test.git</span><br></pre></td></tr></table></figure>

<p>绑定远程仓库，那串链接实际上就是下图所示的链接</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116174651267.png" alt="image-20220116174651267"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116174719454.png" alt="image-20220116174719454"></p>
<p>再输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin "master"</span><br></pre></td></tr></table></figure>

<p>推送到远程仓库</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116174931069.png" alt="image-20220116174931069"></p>
<p>此时已经成功了，可以去gitee查看一下</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116174951924.png" alt="image-20220116174951924"></p>
<p>此时发现README.md已经上传成功了</p>
<h2 id="三、多人协作开发"><a href="#三、多人协作开发" class="headerlink" title="三、多人协作开发"></a>三、多人协作开发</h2><p>​    项目会分为多个分支，master是主分支，是已经测试成功上线运行的代码，dev是develop的缩写，是开发时使用的分支，如果需要的话，还可以有一个测试test分支，用来在上线前进行测试。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116175538437.png" alt="image-20220116175538437"></p>
<p>​    所以在开发时，开发人员会将代码克隆一份到自己的本地库，再进行并行开发，最后合并即可。</p>
<p>​    首先先把合作的人拉进仓库中，找到右上方的管理</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116175738979.png" alt="image-20220116175738979"></p>
<p>再点击仓库成员管理</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116175827179.png" alt="image-20220116175827179"></p>
<p>点击邀请用户</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116175946906.png" alt="image-20220116175946906"></p>
<p>选择喜欢的方式，邀请开发者进入即可，不过免费版只能最多5个人合作</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180021528.png" alt="image-20220116180021528"></p>
<p>为了保证master分支的安全，可以设置权限，保证只有特定的人可以合并master分支</p>
<p>点击保护分支设置</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180117230.png" alt="image-20220116180117230"></p>
<p>点击新建规则</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180143668.png" alt="image-20220116180143668"></p>
<p>根据需要设立规则</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180251458.png" alt="image-20220116180251458"></p>
<p>回到仓库首页，点击管理分支</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180354756.png" alt="image-20220116180354756"></p>
<p>将master设置为保护分支即可</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180440617.png" alt="image-20220116180440617"></p>
<p>设置好以后，现在以一个人为例，演示协作开发的过程：</p>
<p>​    1.新建一个文件夹，当做本地仓库，来clone该项目，克隆地址在仓库首页就能找到</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180606894.png" alt="image-20220116180606894"></p>
<p>新建的文件夹取个自己觉得合适的名字，比如自己的名字之类的</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180657484.png" alt="image-20220116180657484"></p>
<p>终端中进入该文件夹</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180717946.png" alt="image-20220116180717946"></p>
<p>进行clone</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/BananaAres/test.git</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180804760.png" alt="image-20220116180804760"></p>
<p>可以看到，已经clone下来了</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180827163.png" alt="image-20220116180827163"></p>
<p>之后进入项目文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd test</span><br></pre></td></tr></table></figure>



<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116180917450.png" alt="image-20220116180917450"></p>
<p>由于现在还没有develop分支，我们可以预先创建一个，后续的开发者可以在这个分支上进行合作编码</p>
<p>先创建一个develop分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch develop</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181248083.png" alt="image-20220116181248083"></p>
<p>然后进入分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure>

<p>此时如果直接push，会提示</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181421400.png" alt="image-20220116181421400"></p>
<p>我们按照提示，输入命令之后再push</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin develop</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181518011.png" alt="image-20220116181518011"></p>
<p>此时到gitee查看是否添加分支成功</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181553813.png" alt="image-20220116181553813"></p>
<p>可以看到，此时分支添加成功了</p>
<p>​    现在我们已经在develop分支中了，我们可以根据我们需要开发的功能，再创建一个分支，并在该分支上工作，比如要开发一个登陆功能，可以再创建一个feature-login分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch feature-login</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181724225.png" alt="image-20220116181724225"></p>
<p>切换到该分支中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature-login</span><br></pre></td></tr></table></figure>



<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181801533.png" alt="image-20220116181801533"></p>
<p>此时我们可以进行开发，这里就创建一个新文件代替开发</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181848835.png" alt="image-20220116181848835"></p>
<p>开发好后，我们将修改加入本地缓冲区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116181933718.png" alt="image-20220116181933718"></p>
<p>之后将其提交到本地库，-m后的可以随便写，不是定死的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;sdh-login&#39;</span><br></pre></td></tr></table></figure>



<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116182014610.png" alt="image-20220116182014610"></p>
<p>之后我们切换到develop分支后，将feature-login分支合并到develop分支中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge feature-login</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116182233713.png" alt="image-20220116182233713"></p>
<p>此时feature-login分支已经没用了，将其删除，防止分支太多导致冗余</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d feature-login</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116182401617.png" alt="image-20220116182401617"></p>
<p>然后push即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116182429757.png" alt="image-20220116182429757"></p>
<p>此时前往gitee查看，发现master分支内容没有改变</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116182505924.png" alt="image-20220116182505924"></p>
<p>切换到develop分支，发现内容已经修改</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20220116182523900.png" alt="image-20220116182523900"></p>
<p>至此，协作编码基本流程演示完毕，其他角色流程相同</p>
]]></content>
      <categories>
        <category>【git】</category>
      </categories>
      <tags>
        <tag>【git】</tag>
      </tags>
  </entry>
  <entry>
    <title>java八股文</title>
    <url>/2021/11/11/java%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h1 id="JAVA面试八股文"><a href="#JAVA面试八股文" class="headerlink" title="JAVA面试八股文"></a>JAVA面试八股文</h1><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="1-JDK、JRE、JVM三者区别和联系"><a href="#1-JDK、JRE、JVM三者区别和联系" class="headerlink" title="1. JDK、JRE、JVM三者区别和联系"></a>1. JDK、JRE、JVM三者区别和联系</h2><p>JDK：</p>
<p>Java Development Kit java开发工具</p>
<p>JRE：</p>
<p>Java Runtime Environment java运行时环境</p>
<p>JVM:</p>
<p>Java Virtual Machine java虚拟机</p>
<h2 id="2、JVM虚拟机详解："><a href="#2、JVM虚拟机详解：" class="headerlink" title="2、JVM虚拟机详解："></a>2、JVM虚拟机详解：</h2><p><img src="file:///Users/sundaohan/Library/Application%20Support/typora-user-images/image-20211029203932039.png?lastModify=1636630829" alt="image-20211029203932039"></p>
<p>new出来的东西都放在堆里</p>
<p>栈放局部变量，每个线程开启都会分配一个单独的栈用来存放其局部变量</p>
<p>栈帧，每调用一个方法就会在栈中分配独有的栈帧来存放局部变量</p>
<p>例子程序：</p>
<p>字节码反编译文件：</p>
<p>0处代表将Int类型常量1压入操作数栈</p>
<p>1处代表声明一个局部变量并将int类型值存入局部变量1（操作数栈出栈赋值）（局部变量0是this，即调用当前方法的对象）</p>
<p>2、3处同理</p>
<p>4、5处从局部变量1、2处装载int类型值（压入操作数栈）</p>
<p>6处表示弹出两个数相加后得到3再压入操作数栈</p>
<p>7处表示压入一个10进入操作数栈</p>
<p>9处表示做乘法</p>
<p>10表示代表声明一个局部变量并将int类型值存入局部变量3</p>
<p>11表示将变量3的值装载</p>
<p>12返回这个值</p>
<p>局部变量表负责保存局部变量</p>
<p>操作数栈用来保存操作数</p>
<p>动态链接负责需要调用的方法在方法区中的地址（符号引用转为直接引用）</p>
<p>方法出口是指一个方法运行完之后能找到之前调用它的那一行代码继续运行</p>
<p>程序计数器用来记录当前运行到的那一行代码的地址，方便线程切换时继续运行</p>
<p>对象优先分配到Eden区中，当Eden区满后会触发minor gc即垃圾回收</p>
<p>可达性分析算法：将”GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的都是垃圾对象</p>
<p>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</p>
<p><img src="file:///Users/sundaohan/Library/Application%20Support/typora-user-images/image-20211029212117363.png?lastModify=1636630829" alt="image-20211029212117363"></p>
<p>非垃圾对象会被复制到非空的survivor区，每进行了一次可达性分析，经过的对象就会增长一代，15代以后会被移到老年代</p>
<h2 id="3-JVM调优"><a href="#3-JVM调优" class="headerlink" title="3.JVM调优"></a>3.JVM调优</h2><p>arthas工具</p>
<p>当老年代放满后会先触发full gc，对堆中所有垃圾进行收集，如果还没有改善，之后会触发OOM（内存溢出），调优主要就是要减少full gc次数，因为其的STW(Stop The World)时间很长，即抢占所有线程，专心进行垃圾回收处理</p>
<p>为什么要有STW：不让对象的垃圾状态变化，影响gc的准确性，提高效率</p>
<p>如果一批对象的总大小大于这块Survivor区域内大小的50%，有可能直接进入老年代</p>
<p><strong>阿里面试题：能否对JVM调优，让其几乎不发生full gc</strong></p>
<p>​    将年轻代（eden、survivor）空间调大一些，老年代小一些，这样触发Minor gc（只清理年轻代）的时候就能把产生的垃圾清除</p>
<p>而Eden区太大也有问题，触发minor gc也会STW，空间太大导致搜索垃圾速度慢，STW长</p>
<p>可以使用G1策略（分区回收，满足一定条件立刻开始回收，而不是等到满了再回收）</p>
<p><strong>JVM如何调优</strong></p>
<p>JVM调优主要就是通过定制JVM运行参数来提高JAVA应用程序的运行速度</p>
<p><strong>JVM参数有哪些</strong></p>
<p>JVM参数大概分为三类：</p>
<p>（1）标准指令：-开头，这些事所有HotSpot都支持的参数 java -help可以打印出来</p>
<p>（2）非标准指令：-X开头，通常是跟特定的HotSpot版本对应，可以用java -x打印出来</p>
<p>（3）不稳定参数：-XX开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大，详细文档资料很少 JDK1.8版本下，有几个常用的：</p>
<p>java -xx:+PrintCommandLineFlags：查看当前命令的不稳定指令</p>
<p>Java -XX:+PrintFlagsInitial：查看所有不稳定指令的默认值</p>
<p>java -xx:+PrintFlagsFinal：查看所有不稳定指令最终生效的实际值</p>
<p><strong>怎么查看一个JAVA进程的JVM参数</strong></p>
<p><strong>谈谈了解的JVM参数</strong></p>
<h2 id="4-HashTable和HashMap的区别？"><a href="#4-HashTable和HashMap的区别？" class="headerlink" title="4.HashTable和HashMap的区别？"></a>4.HashTable和HashMap的区别？</h2><p>HashTale的每个方法都加了SCN，是线程安全的，HashMap是线程不安全的</p>
<p>HashMap底层使用数组+链表，从JDK8开始，当链表高度达到8、数组长度超过64，链表转换为红黑树，元素以内部类Node节点存在</p>
<p>（1）计算key的Hash值，二次hash然后对数组长度取模，对应到数组下表</p>
<p>（2）如果没有产生hash冲突（下标位置没有元素），则直接创建Node存入数组</p>
<p>（3）如果产生hash冲突，先进行equal比较，如果相同就取代该元素，如果不同就判断链表高度插入链表，链表高度达到8，并且数组长度达到64则转变为红黑树，长度低于6则将红黑树转回链表</p>
<p>（4）key为null,存在下标0的位置</p>
<p>数组扩容</p>
<p>JDK8使用红黑树解决链表查询过慢的问题</p>
<p>链表缺点：查询慢</p>
<p>优点：插入删除快</p>
<p>红黑树优点：查询快</p>
<p>红黑树缺点：插入删除慢</p>
<h2 id="5、-和equals"><a href="#5、-和equals" class="headerlink" title="5、==和equals"></a>5、==和equals</h2><p>==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址</p>
<p>equals：object中默认也采用==比较，通常会重写</p>
<h2 id="6、ArrayList和LinkedList的区别"><a href="#6、ArrayList和LinkedList的区别" class="headerlink" title="6、ArrayList和LinkedList的区别"></a>6、ArrayList和LinkedList的区别</h2><p>（1）ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问）</p>
<p>扩容机制：数组长度固定，超出长度存数据时需要新建数组，然后再拷贝过去，如果不是尾部插入数据会涉及到元素移动，使用尾插法并指定初始容量可以极大地提高性能、甚至超过linkedList（需要创建大量node对象）</p>
<p>（2）LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐一遍历。</p>
<p>​    遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexOf对list进行了遍历，当结果为空时会遍历整个列表。 </p>
<h2 id="7、泛型中extends和super的区别"><a href="#7、泛型中extends和super的区别" class="headerlink" title="7、泛型中extends和super的区别"></a>7、泛型中extends和super的区别</h2><p>（1）&lt;? extends T&gt; 表示包括T在内的任何T的子类</p>
<p>（2）&lt;? super T&gt; 表示包括T在内的任何T的父类</p>
<h2 id="8、深拷贝和浅拷贝"><a href="#8、深拷贝和浅拷贝" class="headerlink" title="8、深拷贝和浅拷贝"></a>8、深拷贝和浅拷贝</h2><p>​    深拷贝和浅拷贝是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用</p>
<p>（1）浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象</p>
<p>（2）深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部属性指向的是同一个对象</p>
<h2 id="9、重载和重写的区别"><a href="#9、重载和重写的区别" class="headerlink" title="9、重载和重写的区别"></a>9、重载和重写的区别</h2><p>（1）重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同。</p>
<p>方法返回值和访问修饰符不同不叫重载，在编译时就会报错</p>
<p>（2）重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类访问修饰符为private则子类不能重写该方法</p>
<h2 id="10、CountDownLatch和Semaphore的区别和底层原理"><a href="#10、CountDownLatch和Semaphore的区别和底层原理" class="headerlink" title="10、CountDownLatch和Semaphore的区别和底层原理"></a>10、CountDownLatch和Semaphore的区别和底层原理</h2><p>​    CountDownLatch表示计数器，可以给CountDownLatch设置一个数字, 一个线程调CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一， 当数字被减成0后，所有await的线程都将被唤醒。<br>​    对应的底层原理就是，调用await()方法的线程 会利用AQS排队，一旦数字被减为0,则会将AQS中排队的线程依次唤醒。<br>​    Semaphore表示信号量，可以设置许可的个数,表示同时允许最多多少个线程使用该信号量,通过acquire()来获取许可，如果没有许可可用则线程阻塞,并通过AQS来排队，可以通过release0方法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211101192810001.png" alt="image-20211101192810001"></p>
<h2 id="11、ReentrantLock中lock和trylock方法的区别"><a href="#11、ReentrantLock中lock和trylock方法的区别" class="headerlink" title="11、ReentrantLock中lock和trylock方法的区别"></a>11、ReentrantLock中lock和trylock方法的区别</h2><p>lock()是阻塞加锁，直到加锁后才能执行其他操作</p>
<p>trylock是尝试加锁，有返回值，如果加锁成功返回true否则false</p>
<p>//自旋锁</p>
<p>while(!reentrantLock.tryLock()){</p>
<p>}</p>
<h2 id="12、如何查看线程死锁"><a href="#12、如何查看线程死锁" class="headerlink" title="12、如何查看线程死锁"></a>12、如何查看线程死锁</h2><p>（1）可以通过jstack命令来进行查看，jstack命令会显示发生了死锁的线程</p>
<p>（2）两个线程去操作数据库时，数据库发生了死锁，这时可以查询数据库的死锁情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、查询是否锁表</span><br><span class="line">show OPEN TABLES where In_use &gt; 0;</span><br><span class="line">2、查询进程</span><br><span class="line">show processlist;</span><br><span class="line">3、查看正在锁的事务</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line">4、查看等待锁的事务</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure>



<h2 id="13、ThreadLocal的原理和使用场景"><a href="#13、ThreadLocal的原理和使用场景" class="headerlink" title="13、ThreadLocal的原理和使用场景"></a>13、ThreadLocal的原理和使用场景</h2><p>​    每一个Thread对象均含有一个ThreadLoca7Map类型的成员变量threadLocals，它存储本线程中所有ThreadLocal对象及其对应的值。</p>
<p>​    ThreadLocaTMap由一个个Entry对象构成。</p>
<p>​    Entry继承自WeakReference &lt;ThreadLoca1&lt;?&gt;&gt;。一个Entry由ThreadLocal对象和object构成。由此可见，Entry 的key是ThreadLocal对象,并且是一个弱引用。 当没指向key的强引用后，该key就会被垃圾收集器回收。</p>
<p>​    当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key,将值存储进ThreadLocalMap对象中。</p>
<p>​    get方法执行过程类似。ThreadLocal首先会获取当前线程对象,然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key,获取对应的value。由于每一条线程均含有各自私有的ThreadLocalMap容器,这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。 </p>
<p><strong>使用场景：</strong></p>
<p>（1）在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束</p>
<p>（2）线程间数据隔离</p>
<p>（3）进行事务操作，用于存储线程事务信息</p>
<p>（4）数据库连接，Session会话管理</p>
<h2 id="14、Sychronized的偏向锁、轻量级锁、重量级锁"><a href="#14、Sychronized的偏向锁、轻量级锁、重量级锁" class="headerlink" title="14、Sychronized的偏向锁、轻量级锁、重量级锁"></a>14、Sychronized的偏向锁、轻量级锁、重量级锁</h2><p>1.偏向锁:在锁对象的对象头中记录一下当前获取到该锁的线程ID, 该线程下次如果又来获取该锁就可以直接获取到了<br>2.轻量级锁:由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁,偏向锁就会升级为轻量级锁,之所以叫轻量级锁，是为了和重量级锁区分开来,轻量级锁底层是通过自旋来实现的，并不会阻塞线程<br>3.如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁,重量级锁会导致线程阻塞<br>4.自旋锁:自旋锁就是线程在获取锁的过程中,不会去阻塞线程,也就无所谓唤醒线程,阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记,如果没有获取到，则继续循环获取,如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。</p>
<h2 id="15、并发、并行、串行的区别"><a href="#15、并发、并行、串行的区别" class="headerlink" title="15、并发、并行、串行的区别"></a>15、并发、并行、串行的区别</h2><p>串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着</p>
<p>并行在时间上是重叠的，两个任务在同一时刻互不干扰同时进行</p>
<p>并发允许两个任务彼此干扰，同一时间点只有一个人运行，交替执行</p>
<h2 id="16、线程之间如何进行通讯"><a href="#16、线程之间如何进行通讯" class="headerlink" title="16、线程之间如何进行通讯"></a>16、线程之间如何进行通讯</h2><p>1.线程之间可以通过共享内存或基于网络来进行通信<br>2.如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒<br>3.像Java中的wait()、notify()就是阻塞和唤醒<br>4.通过网络就比较简单了,通过网络连接将通信数据发送给对方，当然也要考虑到并发问题,处理方式就是加锁等方式</p>
<h2 id="17、对线程安全的理解"><a href="#17、对线程安全的理解" class="headerlink" title="17、对线程安全的理解"></a>17、对线程安全的理解</h2><p>​    不是线程安全，应该是内存安全，堆是共享内存，可以被所有线程访问</p>
<p>​    当多个线程访问一个对象时，如果不进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的</p>
<p>​    堆是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统,要不然就是内存泄漏。<br>​    在Java中，堆是Java虚拟机所管理的内存中最大的一-块，是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例， 几乎所有的对象实例以及数组都在这里分配内存。<br>​    栈是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化,每个线程的栈互相独立,因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。<br>​    目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全,每个进程只能访问分配给自己的内存空间，而不能访问别的进程的,这是由操作系统保障的。<br>​    在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆(内存)。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p>
<h2 id="18、简述线程池处理流程"><a href="#18、简述线程池处理流程" class="headerlink" title="18、简述线程池处理流程"></a>18、简述线程池处理流程</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211101214939191.png" alt="image-20211101214939191"></p>
<h2 id="19、线程池的底层工作原理"><a href="#19、线程池的底层工作原理" class="headerlink" title="19、线程池的底层工作原理"></a>19、线程池的底层工作原理</h2><p>​    线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时:<br>1.如果此时线程池中的线程数量小于corePoolSize（核心线程数）,即使线程池中的线程都处于空闲状态,也要创建新的线程来处理被添加的任务。<br>2.如果此时线程池中的线程数量等于corePoolSize,但是缓冲队列workQueue未满, 那么任务被放入缓冲队列。<br>3.如果此时线程池中的线程数量大于等于corePoolSize,缓冲队列workQueue满, 并且线程池中的数量小于maximumPoolSize,建新的线程来处理被添加的任务。<br>4.如果此时线程池中的线程数量大于corePoolSize,缓冲队列workQueue满, 并且线程池中的数量等于maximumPoolSize,那么通过handler所指定的策略来处理此任务.<br>5.当线程池中的线程数量大于corePoolSize时,如果某线程空闲时间超过keepAliveTime,线程将被终止。这样,线程池可以动态的调整池中的线程数</p>
<h2 id="20、-GC如何判断对象可以被回收"><a href="#20、-GC如何判断对象可以被回收" class="headerlink" title="20、 GC如何判断对象可以被回收"></a>20、 GC如何判断对象可以被回收</h2><p>（1）引用计数法（java不采用这个）：每个对象有一个引用计数属性，新增一个引用时技术加1，引用释放时技术减1，计数为0时可以回收</p>
<p>​    引用计数法可能会出现A引用B，B引用A，这时候就算都不使用了，但因为相互引用，计数器=1，永远无法回收</p>
<p>（2）可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</p>
<p>GC Roots对象有：</p>
<p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
<p>方法区中类静态属性引用的对象</p>
<p>方法区中常量引用的对象</p>
<p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p>
<p>​    可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程:第- -次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是在由虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()法。<br>​    当对象变成(GC Roots)不可达时, GC会判断该对象是否覆盖(重写)了finalize方法，若末覆盖,则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列， 由- -低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收,否则，对象”复活<br>​    每个对象只能触发一次finalize)方法由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐大家使用，建议遗忘它。</p>
<h2 id="21、什么是字节码，采用字节码的好处？"><a href="#21、什么是字节码，采用字节码的好处？" class="headerlink" title="21、什么是字节码，采用字节码的好处？"></a>21、什么是字节码，采用字节码的好处？</h2><p><strong>java中的编译器和解释器:</strong><br>Java中引入了虚拟机的概念,即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序-个的共同的接口。<br>    编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。<br>    每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码,字节码由虚拟机解释执行,虛拟机将每一条要执行的字节码送给解释器 ，解释器将其翻译成特定机器上的机器码，然后在特定的机器.上运行。这也就是解释了]ava的编译与解释并存的特点。</p>
<p>Java源代—&gt;编译—jm可执行的Java字节码(即虚拟令)–&gt;-jvm—&gt;jvm中解释qi–机器可执行的二进<br>制机器—&gt;程序运行。<br><strong>采用字节码的好处:</strong><br>    Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效,而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h2 id="22、双亲委托模型"><a href="#22、双亲委托模型" class="headerlink" title="22、双亲委托模型"></a>22、双亲委托模型</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211103211618646.png" alt="image-20211103211618646"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。</p>
<p>ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。</p>
<p>AppClassLoader：主要负责加载应用程序的主函数类</p>
<p>tomcat是用的自定义的类加载器：因为tomcat管理很多应用，里面有很多类，如果共用一个类加载器的话，可能会引发冲突</p>
<p>双亲委派模型的好处：</p>
<p>（1）主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String</p>
<p>（2）同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加在就是不同的两个类</p>
<h2 id="23、Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代"><a href="#23、Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代" class="headerlink" title="23、Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代"></a>23、Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代</h2><p>1、年轻代：</p>
<p>(1)Eden区(8)</p>
<p>(2)From Survivor区(1)</p>
<p>(3)To Survivor区(1)</p>
<p>2、老年代</p>
<p>默认对象的年龄达到15后，就会进入老年代</p>
<h2 id="24、JVM有哪些垃圾回收器？如何工作？什么是STW？他都发生在哪些阶段？什么是三色标记？如何解决错标记和漏标记的问题？为什么要设计这么多垃圾回收器？"><a href="#24、JVM有哪些垃圾回收器？如何工作？什么是STW？他都发生在哪些阶段？什么是三色标记？如何解决错标记和漏标记的问题？为什么要设计这么多垃圾回收器？" class="headerlink" title="24、JVM有哪些垃圾回收器？如何工作？什么是STW？他都发生在哪些阶段？什么是三色标记？如何解决错标记和漏标记的问题？为什么要设计这么多垃圾回收器？"></a>24、JVM有哪些垃圾回收器？如何工作？什么是STW？他都发生在哪些阶段？什么是三色标记？如何解决错标记和漏标记的问题？为什么要设计这么多垃圾回收器？</h2><p>STW：stop the world是在垃圾回收算法执行过程中，需要将JVM内存冻结的一种状态，在STW状态下，JAVA的所有线程都是停止执行的，GC线程除外，native方法可以执行，但是不能和JVM交互。GC各种算法优化的重点，就是减少STW</p>
<p>JVM的垃圾回收器：</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104151656334.png" alt="image-20211104151656334"></p>
<p>不分代算法不再有年轻代和老年代之分</p>
<p><strong>（1）Serial：串行</strong></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104152018428.png" alt="image-20211104152018428"></p>
<p>需要GC时，直接暂停，GC完了再继续，是早期垃圾回收器，只有一个线程执行GC，在多CPU架构下，性能会严重下降，只适用于几十兆的内存空间</p>
<p><strong>（2）Parallel：并行</strong></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104152222679.png" alt="image-20211104152222679"></p>
<p>在串行基础上增加多线程GC，PS（Parallel Scavenge）+PO（Parallel Old）这种组合是JDK1.8默认的垃圾回收器，在多CPU架构下，性能比Serial高很多</p>
<p><strong>（3）CMS Concurrent Mark Sweep：</strong></p>
<p>核心思想就是将STW打散，让一部分GC线程与用户线程并行进行</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104162011239.png" alt="image-20211104162011239"></p>
<p>（1）初始标记阶段：STW只标出根对象直接引用的对象</p>
<p>（2）并发标记：继续标记其他对象，与应用程序是并发执行</p>
<p>（3）重新标记：STW对并发执行阶段的对象进行重新标记</p>
<p>（4）并发清除：并行，将产生的垃圾清除，清除过程中会不断产生新的垃圾，叫浮动垃圾。这些垃圾就需要等待到下一次GC过程中清除</p>
<p><strong>（4）G1 Garbage First垃圾优先</strong></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104171019797.png" alt="image-20211104171019797"></p>
<p>内存模型实际不再分代，但是逻辑上分代。将内存分成小块Region，每个region可以隶属于不同的年代</p>
<p>GC分为四个阶段：</p>
<p>1.初始标记，标记处GCRoot直接引用的对象，stw</p>
<p>2.标记Region，通过Rset标记出上一个阶段标记的Region引用到的Old区Region，并发</p>
<p>3.并发标记，跟CMS步骤差不多，遍历范围不再是整个OLD区，而是只需哟啊遍历第二部标记出来的Region</p>
<p>4.重新标记，跟CMS中的重新标记过程差不多</p>
<p>5.垃圾清理：与CMS不同的是，G1采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region，而这个阶段G1只选择垃圾较多的Region来清理，并不是完全清理</p>
<h2 id="25、-如何判断一个对象是不是垃圾"><a href="#25、-如何判断一个对象是不是垃圾" class="headerlink" title="25、 如何判断一个对象是不是垃圾"></a>25、 如何判断一个对象是不是垃圾</h2><p>两种方法</p>
<p>1、引用计数法：给堆内存中的每个记录记录一个引用数，引用个数为0就认为是垃圾，这是早期JDK使用的方法。无法解决循环引用问题，会造成内存泄漏，进而引发内存溢出</p>
<p>2、根可达算法：这种方式是在内存中，从引用根对象向下一直找引用，找不到的就是垃圾</p>
<p>哪些是GC Root？ Stack =&gt; JVM Stack，Native Stack，class类，run-time constant pool常量池，static reference静态变量</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、ACID靠什么保证"><a href="#1、ACID靠什么保证" class="headerlink" title="1、ACID靠什么保证"></a>1、ACID靠什么保证</h2><p>A：原子性，由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sq|<br>C：一致性，由其他三大特性保证、程序代码要保证业务上的一致性<br>I：隔离性，由MVCC来保证<br>D：持久性，由内存+redo log来保证, mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo<br>log恢复</p>
<p>InnoDB redo log写盘，InnoDB事务进入prepare状态，</p>
<p>如果前面prepare成功，binlog写盘，再继续将事务日志持久化到binlog，如果持久化成功，那么InnoDB事务进入commit状态（在redo log中写一个commit记录）</p>
<p>redo log的刷盘会在系统空闲时进行</p>
<h2 id="2、B树和B-树的区别，为什么MySQL使B-树"><a href="#2、B树和B-树的区别，为什么MySQL使B-树" class="headerlink" title="2、B树和B+树的区别，为什么MySQL使B+树"></a>2、B树和B+树的区别，为什么MySQL使B+树</h2><p>B树的特点: .<br>1.节点排序</p>
<p>2.一个节点了可以存多个元素，多个元素也排序了</p>
<p>B+树的特点:<br>1.拥有B树的特点<br>2.叶子节点之间有指针<br>3.非叶子节点上的元素在叶子节点上都冗除了，也就是叶子节点中存储了所有的元素,并且排好顺序</p>
<p>​    Mysql索引使用的是B +树,因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的,然后通过一个节点中可以存储多个元素,从而可以使得B+树的高度不会太高,在Mysq|中- 个Innodb页就是一个B+ 树节点, 一个Innodb页默认16kb,所以一般情况下一颗两层的B +树可以存2000万行左右的数据，然后通过利用B +树叶子节点存储了所有数据并且进行了排序,并且叶子节点之间有指针,可以很好的支持全表扫描，范围查找等SQL语句。</p>
<h2 id="3、MySQL的索引结构是什么样的，聚簇索引和非聚簇索引又是什么？"><a href="#3、MySQL的索引结构是什么样的，聚簇索引和非聚簇索引又是什么？" class="headerlink" title="3、MySQL的索引结构是什么样的，聚簇索引和非聚簇索引又是什么？"></a>3、MySQL的索引结构是什么样的，聚簇索引和非聚簇索引又是什么？</h2><p>进化路程：</p>
<p>二叉树》AVL树（平衡树）》红黑树》B树》B+树</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104212154216.png" alt="image-20211104212154216"></p>
<p>聚簇索引就是数据和索引是在一起的，聚簇索引中包含索引键值和所有数据</p>
<p>MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址，InnoDB采用的是聚簇索引，树的叶子结点上的data就是数据本身。</p>
<p>聚簇索引的数据物理存放地址和索引顺序是一致的，所以一个表中只能有一个聚簇索引，而非聚簇索引可以有多个</p>
<p>​    InnoDB中，如果表定义了PK，那PK就是聚簇索引吗。如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则InnoDB会创建一个隐藏的row-id作为聚簇索引</p>
<p><strong>MySQL的覆盖索引和回表</strong></p>
<p>​    如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度会更快</p>
<p>​    实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引中。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211104213216732.png" alt="image-20211104213216732"></p>
<h2 id="4、Innodb是如何实现事务的"><a href="#4、Innodb是如何实现事务的" class="headerlink" title="4、Innodb是如何实现事务的"></a>4、Innodb是如何实现事务的</h2><p>Innodb通过Buffer Pool, LogBuffer, Redo Log, Undo Log来实现事务,以一个update语句为例:</p>
<ol>
<li>Innodb在收到一个update语句后，先根据条件找到数据所在的页,并将该页缓存在Buffer Pool中</li>
<li>执行update语询, 修改Buffer Pool中的数据,也就是内存中的数据</li>
<li>针对update语句生成一个RedoLog对象, 并存入LogBuffer中</li>
<li>针对update语句生成undolog日志，用于事务回滚</li>
<li>如果事务提交,那么则把RedoLog对象进行持久化,后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中</li>
<li>如果事务回滚，则利用undolog日志进行回滚</li>
</ol>
<h2 id="5、mysql索引的数据结构，各自优劣"><a href="#5、mysql索引的数据结构，各自优劣" class="headerlink" title="5、mysql索引的数据结构，各自优劣"></a>5、mysql索引的数据结构，各自优劣</h2><p>​    索引的数据结构和具体存储弓|擎的实现有关,在MySQL中使用较多的索引|有Hash索引，B+树索引等，InnoDB存储弓擎的默认索引实现为: B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快;余大部分场景,建议选择BTree索引。<br>B+树:<br>​    B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1,而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当,不会出现大幅波动，而且基于索弓|的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211105152438245.png" alt="image-20211105152438245"></p>
<p>​    如果是等值查询，那么哈希索弓|明显有绝对优势，因为只需要经过一次算法即可找到相应的键值;前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描,直到找到相应的数据;<br>​    如果是范围查询检索，这时候哈希索弓|就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引|完成范围查询检索;<br>​    哈希索弓|也没办法利用索引|完成排序,以以like ‘xxx%’这样的部分模糊查询(这种部分模糊查询，其实本质上也是范围查询) ;<br>​    哈希索引也不支持多列联合索引的最左匹配规则;<br>​    B+树索弓|的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索弓|的效率也是极低的，因为存在哈希碰撞问题。</p>
<h2 id="6、MySQL的集群是如何搭建的？读写分离是怎么做的？"><a href="#6、MySQL的集群是如何搭建的？读写分离是怎么做的？" class="headerlink" title="6、MySQL的集群是如何搭建的？读写分离是怎么做的？"></a>6、MySQL的集群是如何搭建的？读写分离是怎么做的？</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211105152838312.png" alt="image-20211105152838312"></p>
<p>通过将主节点的Binlog同步给从节点完成主从之间的数据同步。</p>
<p>MySQL的主从集群只会将binlog从主节点同步到从节点，而不会反过来同步，所以需要读写分离</p>
<p>因为要保证主从之间的数据一致，写数据只能在主节点完成</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211105154319842.png" alt="image-20211105154319842"></p>
<p>​    由于binlog的发送过程是异步的吗，主服务在向客户端反馈执行结果时，是不知道binlog是否同步成功了的，这时候如果主服务器宕机了，而从服务还没有备份到新执行的binlog，那么就有可能丢失数据。</p>
<p>​    靠MySQL的半同步复制机制来保证数据安全</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211105154520857.png" alt="image-20211105154520857"></p>
<p>这种半同步复制相比异步复制，能够有效的提高数据的安全性。但是这种安全性也不是绝对的，他只保证事务提交后的binlog至少传输到了一个从库,并且并不保证从库应用这个事务的binlog是成功的。另一方面，半同步复制机制也会造成一定程度的延迟，这个延迟时间最少一个TCP/IP请求往返的时间。</p>
<h2 id="7、MySQL执行计划怎么看"><a href="#7、MySQL执行计划怎么看" class="headerlink" title="7、MySQL执行计划怎么看"></a>7、MySQL执行计划怎么看</h2><p>执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数</p>
<p>EXPLAIN SELECT * from A where X=? and Y=?</p>
<p>![image-20211105155804961](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211105155804961.png)</p>
<p>1.id :是一个有顺序的编号，是查询的顺序号,有几个select就显示几行。id的顺序是按select出现的顺序增<br>长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NULL最后执行。<br>2.selectType 表示查询中每个select子句的类型<br>●SIMPLE: 示此查询不包含UNION查询或子查询<br>●PRIMARY:表示此查询是最外层的查询(包含子查询)<br>●SUBQUERY:子查询中的第一个SELECT<br>●UNION:表示此查询是 UNION的第二或随后的查询<br>●DEPENDENT UNION: UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>●UNION RESULT, UNION的结果<br>●DEPENDENT SUBQUERY:子查询中的第一个 SELECT,取决于外面的查询.即子查询依赖于外层查询的结果.<br>●DERIVED: 衍生，表示导出表的SELECT (FROM子句的子查询)<br>3.table:表示该语句查询的表<br>4.type:优化sq的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围:</p>
<p>5.possible_ keys:它表示Mysq|在执行该sq|语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用<br>到。<br>6.key:此字段是mysql在当前查询时所真正使用到的索引。他是possible_ keys的子集</p>
<p>7.key_ len:表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用,这也是我们优化<br>sq|时，评估索引的重要指标<br>9.rows: mysql 查询优化器根据统计信息，估算该sq|返回结果集需要扫描读取的行数，这个值相关重要,索引优<br>化之后，扫描读取的行数越多,说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大<br>10.filtered:返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少<br>11.extra<br>●using filesort :表示mysql对结果集进行外部排序，不能通过索弓|顺序达到排序效果。-般有using filesort都建议优化去掉，因为这样的查询cpu资源消耗大,延时大。<br>●using index:覆盖索引扫描，表示查询在索弓|树中就可查找所需数据，不用扫描表数据文件,往往说明性能不错。<br>●using temporary:查询有使用临时表,一般出现于排序， 分组和多表join的情况，查询效率不高， 建议优化。<br>●using where : sq|使用了where过滤效率较高。</p>
<h2 id="8、mysql主从同步原理"><a href="#8、mysql主从同步原理" class="headerlink" title="8、mysql主从同步原理"></a>8、mysql主从同步原理</h2><p>mysql主从同步的过程:<br>    Mysql的主从复制中主要有三个线程: master (bin1og dump thread) 、slave (I/O thread 、SQL thread)，Master- 条线程和Slave中的两条线程。<br>●主节点binlog,主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog 是数据库服务器启动的<br>那一刻起，保存所有修改数据库结构或内容的一个文件。<br>●主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。<br>●从节点I/O线程接收binlog内容,并将其写入到relay log文件中。<br>●从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。<br>注:主从节点使用binglog文件+ position偏移量来定位主从同步的位置,从节点会保存其已接收到的偏移量,如果从节点发生宕机重启，则会自动从position的位置发起同步。<br>    由于mysq|默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理,这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。</p>
<p>全同步复制<br>    主库写入binlog后强制同步日志到从库,所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p>
<p>半同步复制</p>
<p>​    和全同步不同的是，半同步复制的逻辑是从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成</p>
<h2 id="9、MySQL有哪几种数据存储引擎，有什么区别"><a href="#9、MySQL有哪几种数据存储引擎，有什么区别" class="headerlink" title="9、MySQL有哪几种数据存储引擎，有什么区别"></a>9、MySQL有哪几种数据存储引擎，有什么区别</h2><p>使用 show ENGINES可以看到所有引擎，最为常用的是MyISAM和InnoDB两种</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211105212307913.png" alt="image-20211105212307913"></p>
<p>MyISAM和InnDB的区别：</p>
<p>1、存储文件。MyISAM每个表有两个文件，MYD和MYISAM文件，MYD是数据文件，MYI是索引文件，而InnDB每个表只有一个文件，idb。</p>
<p>2、Innodb支持事务，支持行级锁，支持外键</p>
<p>3、InnoDB支持XA事务</p>
<p>4、InnoDB支持savePoints</p>
<h2 id="9、简述mysql中索引类型以及对数据库性能的影响"><a href="#9、简述mysql中索引类型以及对数据库性能的影响" class="headerlink" title="9、简述mysql中索引类型以及对数据库性能的影响"></a>9、简述mysql中索引类型以及对数据库性能的影响</h2><p>普通索引:允许被索引的数据列包含重复的值。<br>唯一索引:可以保证数据记录的唯一性。<br>主键:是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一 条记录, 使用关键字PRIMARY KEY来创建。<br>联合索引:索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。<br>全文索引:通过建立倒排索引,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引|擎使用的一种关键技术。可以通过ALTER TABLE table_ name ADD FULLTEXT (column);创建全文索引</p>
<p>索引可以极大的提高数据的查询速度。<br>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。<br>但是会降低插入、删除、更新表的速度，因为在执行这些写操作时,还要操作索引文件<br>索弓|需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1、-RDB和AOF机制"><a href="#1、-RDB和AOF机制" class="headerlink" title="1、 RDB和AOF机制"></a>1、 RDB和AOF机制</h2><p>RDB: Redis DataBase<br>    在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork-个子进程,先将数据集写入临时文<br>件，写入成功后，再替换之前的文件，用二进制压缩存储。<br>优点:<br>1、整个Redis数据库将只包含-个文件dump.rdb,方便持久化。<br>2、容灾性好，方便备份。<br>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令,所以是I0最大化。使用单独子进程来进行<br>持久化，主进程不会进行任何10操作,保证了redis的高性能<br>4.相对于数据集大时，比AOF的启动效率更高。<br>缺点:<br>1、数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这<br>种方式更适合数据要求不严谨的时候)<br>2、由于RDB是通过fork子 进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务<br>器停止服务几百毫秒，甚至是1秒钟。</p>
<h2 id="2、Redis单线程为什么这么快"><a href="#2、Redis单线程为什么这么快" class="headerlink" title="2、Redis单线程为什么这么快"></a>2、Redis单线程为什么这么快</h2><p>​    Redis基于Reactor模式开发了网络事件处理器、文件事件处理器file event handler。它是单线程的，所以Redis才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket,根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。<br>​    文件事件处理器的结构包含4个部分:多个Socket、I0多路复用程序、文件事件分派器以及事件处理器(命令请求处理器、命令回复处理器、连接应答处理器等)。<br>​    多个Socket可能并发的产生不同的事件，10多路复用程序会监听多个Socket,会将Socket放入一个队列中排队，每次从队列中有序、同步取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。然后一个Socket的事件处理完之后，10多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件,来选择对应的事件处理器来处理。</p>
<p>1、Redis启动初始化时,将连接应答处理器跟AE_ READABLE事件关联。<br>2、若一个客户端发起连接，会产生一个AE_ <em>READABLE事件,然后由连接应答处理器负责和客户端建立连接,创<br>建客户端对应的socket,同时将这个socket的AE</em> READABLE事件和命令请求处理器关联，使得客户端可以向主服<br>务器发送命令请求。<br>3、当客户端向Redis发请求时(不管读还是写请求)，客户端socket都会产生一 个AE_ READABLE事件,触发命令<br>请求处理器。处理器读取客户端的命令内容，然后传给相关程序执行。<br>4、当Redis服务 器准备好给客户端的响应数据后，会将socket的AE_ WRITABLE事件和命令回复处理器关联,当客<br>户端准备好读取响应数据时，会在socket产生一个AE_ <em>WRITABLE事件，由对应命令回复处理器处理，即将准备好<br>的响应数据写入socket,供客户端读取。</em></p>
<p>5、命令回复处理器全部写完到socket后，就会删除该socket的AE_ _WRITABLE事件和命令回复处理器的映射。</p>
<p>单线程快的原因</p>
<p>（1）纯内存操作</p>
<p>（2）核心是基于非阻塞的IO多路复用机制</p>
<p>（3）单线程反而避免了多线程的频繁上下文切换带来的性能问题</p>
<h2 id="3、redis的持久化机制"><a href="#3、redis的持久化机制" class="headerlink" title="3、redis的持久化机制"></a>3、redis的持久化机制</h2><p>​    RDB: Redis DataBase将某一个时刻的内存快照 (Snapshot) ，以二进制的方式写入磁盘。<br>手动触发:<br>●save命令，使Redis处于阻塞状态，直到RDB持久化完成,才会响应其他客户端发来的命令,所以在生产环<br>境一定要慎用<br>●bgsave命令, fork出一个子进程执行持久化，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程，<br>就可以响应客户端请求了</p>
<p>自动触发:<br>●savemn:在m秒内，如果有n个键发生改变,则自动触发持久化，通过bgsave执行,如果设置多个、只要满足其一就会触发,配置文件有默认配置(可以注释掉)<br>●flushall: 用于清空redis所有的数据库 ，flushdb清空 当前redis所在库数据(默认是0号数据库),会清空RDB文件，同时也会生成dump.rdb.内容为空<br>●主从同步:全量同步时会自动触发bgsave命令,生成rdb发送给从节点</p>
<p>优点:<br>1、整个Redis数据库将只包含一个文件dump.rdb,方便持久化。<br>2、容灾性好,方便备份。<br>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是I0最大化。使用单独子进程来进行持久化，主进程不会进行任何10操作,保证了redis的高性能<br>4.相对于数据集大时，比AOF的启动效率更高。</p>
<p>缺点:<br>1、数据安全性低。RDB 是间隔一段时间进行持久化， 如果持久化之间redis发生故障，会发生数据丢失。所以这<br>种方式更适合数据要求不严谨的时候)<br>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此,如果当数据集较大时,可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。会占用cpu<br>AOF: Append Only File以日志的形式记录服务 器所处理的每一个写、 删除操作，查询操作不会记录，以收本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘<br>1、所有的写命令会追加到AOF缓冲中。<br>2、AOF缓冲区根据对应的策略向硬盘进行同步操作。<br>3、随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。<br>4、当Redis重启时，可以加载AOF文件进行数据恢复。</p>
<p>同步策略: .<br>●每秒同步:异步完成，效率非常高，- -旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失<br>●每修改同步:同步持久化,每次发生的数据变化都会被立即记录到磁盘中,最多丢一条<br>●不同步:由操作系统控制，可能丢失较多数据<br>●优点:<br>1、数据安全<br>2、通过append模式写文件,即使中途服务器宕机也不会破坏已经存在的内容,可以通过redis-check-aof工具解决数据一致性问题。<br>3、AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩的目的<br>●缺点:<br>1、AOF文件比RDB文件大，且恢复速度慢。<br>2、数据集大的时候，比rdb启动效率低。<br>3、运行效率没有RDB高</p>
<p>AOF文件比RDB更新频率高，优先使用AOF还原数据。<br>AOF比RDB更安全也更大<br>RDB性能比AOF好<br>如果两个都配了优先加载AOF</p>
<h2 id="4、Redis的过期键的删除策略"><a href="#4、Redis的过期键的删除策略" class="headerlink" title="4、Redis的过期键的删除策略"></a>4、Redis的过期键的删除策略</h2><p>​    Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。<br>●惰性过期:只有当访问一个key时， 才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问,从而不会被清除，占用大量内存。<br>●定期过期:每隔一定的时间，会扫描一 定数量的数据库的expires字典中一定数量的key,并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针,<br>value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)<br>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h2 id="5、Redis的分布式锁底层如何实现"><a href="#5、Redis的分布式锁底层如何实现" class="headerlink" title="5、Redis的分布式锁底层如何实现"></a>5、Redis的分布式锁底层如何实现</h2><p>1.首先利用setnx来保证:如果key不存在才能获取到锁,如果key存在,则获取不到锁<br>2.然后还要利用lua脚本来保证多个redis操作的原子性<br>3.同时还要考虑到锁过期,所以需要额外的一个看]狗定时任务来监听锁是否需要续约<br>4.同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+ 1个节点申请锁,都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</p>
<h2 id="6、Redis有哪些数据结构？分别有哪些典型的应用场景"><a href="#6、Redis有哪些数据结构？分别有哪些典型的应用场景" class="headerlink" title="6、Redis有哪些数据结构？分别有哪些典型的应用场景"></a>6、Redis有哪些数据结构？分别有哪些典型的应用场景</h2><p>Redis的数据结构有:<br>1.字符串:可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构,还包括可以实现计数器、Session共享、 分布式ID<br>2.哈希表:可以用来存储一些key-value对, 更适合用来存储对象<br>3.列表: Redis的列表通过命令的组合,既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据。<br>4.集合:和列表类似，也可以存储多个元素,但是不能重复，集合可以进行交集、并集、差集操作,从而可以实现类似,<br>我和某人共同关注的人、朋友圈点赞等功能<br>5.有序集合:集合是无序的,有序集合可以设置顺序，可以用来实现排行榜功能</p>
<h2 id="7、-Redis主从复制的原理"><a href="#7、-Redis主从复制的原理" class="headerlink" title="7、 Redis主从复制的原理"></a>7、 Redis主从复制的原理</h2><p>![image-20211107205606534](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211107205606534.png)</p>
<p>​    通过执行slaveof命令或设置slaveof选项，让一个服务 器去复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库-般是只读的，并接受主数据库同步过来<br>的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库<br>全量复制:<br>(1)节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存页表复制)、硬盘lO的<br>(2)节点通过网络将RDB文件发送给从节点,对主从节点的带宽都会带来很大的消耗<br>(3)从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令;如果从节点执行bgrewriteaof,也会带来额外的消耗<br>部分复制:<br>1.复制偏移<br>2.复制积压缓冲区:主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点<br>offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。<br>3.服务器运行ID(runid):每个Redis节点, 都有其运行ID,运行ID由节点在启动时自动生成，主节点会将自己的<br>运行ID发送给从节点，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来<br>判断同步的进度:</p>
<p>1.复制偏移量:执行复制的双方，主从节点，分别会维护一个复制偏移量offset<br>2.复制积压缓冲区:主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时,将无法执行部分复制，只能执行全量复制。<br>3.服务器运行ID(runid):每个Redis节点, 都有其运行ID,运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度:</p>
<p>​    如果从节点保存的runid与主节点现在的runid相同,说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况);<br>​    如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p>
<h2 id="8、布隆过滤器原理，优缺点"><a href="#8、布隆过滤器原理，优缺点" class="headerlink" title="8、布隆过滤器原理，优缺点"></a>8、布隆过滤器原理，优缺点</h2><p>位图: int[10], 每个int类型的整数是4*8=32个bit,则int[10]- 共有320 bit,每个bit非0即1,初始化时都是0</p>
<p>添加数据时，将数据进行hash得到hash值,对应到bit位,将该bit改为1，hash函数可以定义多个，则一个数据添加会将多个(hash函数个数) bit改为1, 多个hash函数的目的是减少hash碰撞的概率</p>
<p>查询数据: hash函数计算得到hash值,对应到bit中，如果有一个为0, 则说明数据不在bit中,如果都为1,则该<br>数据可能在bit中</p>
<p>优点:<br>●占用内存小<br>●增加和查询元素的时间复杂度为: O(K), (K为哈希函数的个数,一般比较小)，与数据量大小无关<br>●哈希函数相互之间没有关系，方便硬件并行运算<br>●布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势<br>●数据量很大时,布隆过滤器可以表示全集<br>●使用同一组散列函数的布隆过滤器可以进行交、并、差运算</p>
<p>缺点:<br>●误判率,即存在假阳性(False Position), 不能准确判断元素是否在集合中<br>●不能获取元素本身<br>●一般情况下不能从布隆过滤器中删除元素</p>
<h2 id="9、-常见的缓存淘汰算法"><a href="#9、-常见的缓存淘汰算法" class="headerlink" title="9、 常见的缓存淘汰算法"></a>9、 常见的缓存淘汰算法</h2><p>FIFO (First In First Out,先进先出)，根据缓存 被存储的时间，离当前最远的数据优先被淘汰;<br>LRU (Least Recently Used,最近最少使用)， 根据最近被使用的时间，离当前最远的数据优先被淘汰;<br>LFU (Least Frequently Used,最不经常使用)，在一 段时间内, 缓存数据被使用次数最少的会被淘汰。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="1、SpringBoot、Spring-MVC和Spring有什么区别"><a href="#1、SpringBoot、Spring-MVC和Spring有什么区别" class="headerlink" title="1、SpringBoot、Spring MVC和Spring有什么区别"></a>1、SpringBoot、Spring MVC和Spring有什么区别</h2><p>spring是一个I0C容器，用来管理Bean,使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补00P的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</p>
<p>springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet,来接收请求,然后定义了一套路由策略 (url|到handle的映射) 及适配执行handle,将handle结果使用视图解析技术生成视图展现给前端</p>
<p>springboot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc应用， 简<br>化了配置(约定了默认配置)，整合了一系列的解决方案(starter机制) 、redis、 mongodb、 es,可以开箱即用</p>
<h2 id="2、-和-的区别"><a href="#2、-和-的区别" class="headerlink" title="2、 #{}和${}的区别"></a>2、 #{}和${}的区别</h2><p>#{}是预编译处理、是占位符，${}是字符串替换、 是拼接符。<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement来赋值;<br>Mybatis在处理${}时，就是把${}替换成变量的值， 调用Statement来赋值;<br>#{}的变量替换是在DBMS中、变量替换后，#{} 对应的变量自动加上单引号<br>${}的变量替换是在DBMS外、变量替换后，${} 对应的变量不会加_上单引号<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h2 id="3、ApplicationContext和BeanFactory有什么区别"><a href="#3、ApplicationContext和BeanFactory有什么区别" class="headerlink" title="3、ApplicationContext和BeanFactory有什么区别"></a>3、ApplicationContext和BeanFactory有什么区别</h2><p>​    BeanFactory是Spring中非常核心的组件，表示Bean厂，可以生成Bean, 维护Bean, 而ApplicationContext继承了 BeanFactory,所以ApplicationContext拥有BeanFactory所有的特点, 但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如EnvironmentCapable、MessageSource、ApplicationEventPublisher等接口，从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory不具备的</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109155210675.png" alt="image-20211109155210675"></p>
<p> <img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109155505152.png" alt="image-20211109155505152"></p>
<h2 id="4、Mybatis的插件运行原理"><a href="#4、Mybatis的插件运行原理" class="headerlink" title="4、Mybatis的插件运行原理"></a>4、Mybatis的插件运行原理</h2><p>​    Mybatis 只支持针对ParameterHandler、ResultSetHandler. StatementHandler. Executor 这4种接口的插件，Mybatis 使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，拦截那些你指定需要拦截的方法。</p>
<p>​    编写插件:实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一<br>个接口的哪些方法即可，在配置文件中配置编写的插件。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109160312626.png" alt="image-20211109160312626"></p>
<h2 id="5、MyBatis存在哪些优点和缺点"><a href="#5、MyBatis存在哪些优点和缺点" class="headerlink" title="5、MyBatis存在哪些优点和缺点"></a>5、MyBatis存在哪些优点和缺点</h2><p>优点:<br>1.基于SQL语句编程,相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 单独写，解除sql与程序代码的耦合,便于统-管<br>理。<br>2.与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码,不需要手动开关连接;<br>3.很好的与各种数据库兼容( 因为MyBatis使用JDBC来连接数据库,所以只要JDBC支持的数据库MyBatis都支持)。<br>4.能够与Spring很好的集成;<br>5.提供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护。<br>缺点:</p>
<ol>
<li>SQL语句的编写工作量较大，其当字段移、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差 ，不能随意更换数据库</li>
</ol>
<h2 id="6、SrpingMVC的底层工作原理"><a href="#6、SrpingMVC的底层工作原理" class="headerlink" title="6、SrpingMVC的底层工作原理"></a>6、SrpingMVC的底层工作原理</h2><p>1.用户发送请求至前端控制器DispatcherServlet.</p>
<p>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p>3.处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给DispatcherServlet.</p>
<p>4.DispatcherServlet调用HandlerAdapter处理器适配器。</p>
<p>5.HandlerAdapter经过适配调用具体的处理器(Controller,也叫后端控制器)</p>
<p>6.Controller 执行完成返回ModelAndView.</p>
<p>7.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>
<p>8.DispatcherServlet 将ModelAndView传给ViewReslover视图解析器。</p>
<p>9.ViewReslover解析后返回具体View。</p>
<p>10.DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。</p>
<p>11.DispatcherServlet响应用户。</p>
<h2 id="7、SpringBoot自动配置原理"><a href="#7、SpringBoot自动配置原理" class="headerlink" title="7、SpringBoot自动配置原理"></a>7、SpringBoot自动配置原理</h2><p>@Import + @configuration + Spring spi</p>
<p>自动配置类由各个starter提供，使用@Configuration+@Bean定义配置类，放到META-INF/spring.factories下</p>
<p>使用Spring spi扫描META-INF/spring.factories下的配置类</p>
<p>使用@Import导入自动配置类</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109203555364.png" alt="image-20211109203555364"></p>
<h1 id="8、-SpringMVC中的控制器是不是单例模式，如果是如何保证线程安全？"><a href="#8、-SpringMVC中的控制器是不是单例模式，如果是如何保证线程安全？" class="headerlink" title="8、 SpringMVC中的控制器是不是单例模式，如果是如何保证线程安全？"></a>8、 SpringMVC中的控制器是不是单例模式，如果是如何保证线程安全？</h1><p>控制器是单例模式</p>
<p>单例模式下会有线程安全问题</p>
<p>spring中保证线程安全的方法：</p>
<p>1、将scop设置成非singleton，而是prototype，request，但是当高并发时，每个线程都有一个对象会造成系统负担</p>
<p>2、最好的方式是将控制器设置成无状态模式，在控制器中不要携带数据，但是可以引用无状态的service和dao即没有属性，controller引用service，service引用dao也是无状态的，因为他们两个本身就无状态，无状态互相引用还是无状态</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109205809340.png" alt="image-20211109205809340"></p>
<h2 id="9、spring框架中用到了哪些设计模式"><a href="#9、spring框架中用到了哪些设计模式" class="headerlink" title="9、spring框架中用到了哪些设计模式"></a>9、spring框架中用到了哪些设计模式</h2><p>1、简单工厂:由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。（不属于23种设计模式）<br>    Spring中的BeanFactory就是简单工厂模式的体现，根据传入一-个唯一的标识来获得Bean对象， 但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>
<p>2、工厂方法:<br>    实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getobject()方法，所以返回的不是factory这个bean，而是这个bean . getojbect()方法的返回值。<br>3、单例模式:保证一个类仅有一 个实例，并提供一个访问它的全 局访问点<br>    spring对单例的实现: spring中的单例模式完成 了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p>
<p>4、适配器模式:<br>    Spring定义了-一个适配接口，使得每一种Controller 有一- 种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一一个适配器类就完成了SpringMVC的扩展了。<br>5、装饰器模式:动态地给一个对象添加一 -些额外的职责。就增加功能来说，Decorator模式相比生 成子类更为灵活。<br>    Spring中用到的包装器模式在类名上有两种表现:一种是类名中 含有Wrapper，另一一种是类名中含Decorator。</p>
<p>6、动态代理:<br>    切面在应用运行的时刻被织入。一 般情况下，在织入切面时，AOP 容器会为目标对象创建动态的创建一一个代理对象。<br>    SpringAOP就是以这种方式织入切面的。<br>    织入:把切面应用到目标对象并创建新的代理对象的过程。<br>7、观察者模式:<br>    spring的事件驱动模型使用的是观察者模式，Spring中observer 模式常用的地方是1istener的实现。<br>8、策略模式:<br>    Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。</p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="1、zk的watch机制实现原理"><a href="#1、zk的watch机制实现原理" class="headerlink" title="1、zk的watch机制实现原理"></a>1、zk的watch机制实现原理</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109213251960.png" alt="image-20211109213251960"></p>
<p>通过动态添加的watcher会覆盖创建对象时指定的watcher</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109215408507.png" alt="image-20211109215408507"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211109220507217.png" alt="image-20211109220507217"></p>
<h2 id="2、zk的初始化选举和崩溃选举过程"><a href="#2、zk的初始化选举和崩溃选举过程" class="headerlink" title="2、zk的初始化选举和崩溃选举过程"></a>2、zk的初始化选举和崩溃选举过程</h2><p>zxld:事务id, sld: 节点id<br>先对比zxld,再对比sId,先投自己，选票内容(zxld, sId) ，遇强改投<br>投票箱:每个节点在本地维护自己和其他节点的投票信息，改投时需要更新信息,并扩播<br>节点状态:<br>●LOOKING,竞选状态。<br>●FOLLOWING, 随从状态，同步leader状态,参与投票。<br>●OBSERVING, 观察状态，同步leader状态,不参与投票。<br>●LEADING, 领导者状态。<br><strong>初始化:没有历史数据，5个节点为例</strong><br>●节点1启动，此时只有一台服务器启动，它发出去的请求没有任何响应，所以它的选举状态一直是LOOKING状<br>●节点2启动,它与节点1进行通信,互相交换自己的选举结果，由于两者都没有历史数据,所以serverld值较大的服务器2胜出,但是由于没有达到半数以上，所以服务器1,2还是继续保持LOOKING状态<br>●节点3启动，与1、2节点通信交互数据，服务器3成为服务器1,2,3中的leader, 此时有三台服务器选举了3,所以3成为leader<br>●节点4启动,理论上服务器4应该是服务器1,2,3,4中最大的， 但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能切换为follower</p>
<p>●节点5启动,同4一样<br><strong>崩溃选举:</strong><br>●更状态，leader故障后，follower进 入looking状态<br>●各节点投票,先投自己(zxld, sId) ，再广播投票,<br>●接收到投票，对比zxId和sId,如果本节点小则将票改为接收的投票信息，并记录投票信息，重新广播。否<br>则本节点大、则可不做处理<br>●统计本地投票信息,超过半数,则切换为leading状态并广播</p>
<h2 id="3、zk分布式锁的实现原理"><a href="#3、zk分布式锁的实现原理" class="headerlink" title="3、zk分布式锁的实现原理"></a>3、zk分布式锁的实现原理</h2><p>●上来直接创建一 个锁节点下的一个接一个的临时顺序节点<br>●如果自己不是第一个节点,就对自己上一个节点加监听器<br>●只要上一个节点释放锁，自己就排到前面去了，相当于是一个排队机制。<br>而且用临时顺序节点，如果某个客户端创建临时顺序节点之后，自己宕机了，zk感知到那个客户端宕机，会自删<br>除对应的临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队。解决了惊群效应</p>
<h2 id="4、说说你了解的-分布式锁"><a href="#4、说说你了解的-分布式锁" class="headerlink" title="4、说说你了解的 分布式锁"></a>4、说说你了解的 分布式锁</h2><p>​    分布式锁所要解决的问题的本质是:能够对分布在多台机器中的线程对共享资源的互斥访问。在这个原理上可以有很多的实现方式:<br>1.基于Mysq|,分布式环境中的线程连接同一个数据库,利用数据库中的行锁来达到互斥访问，但是Mysql的加锁和释放锁的性能会比较低，不适合真正的实际生产环境<br>2.基于Zookeeper, Zookeeper中的数据是存在内存的，所以相对于Mysq|性能上是适合实际环境的,诅基于Zookeeper的顺序节点临时节点Watch机制能非常好的来实现的分布式锁<br>3.基于Redis, Redis中的数据也是在内存,基于Redis的消费订阅功能、数据超时时间，lua脚本等功能，也能很好的实现的分布式锁</p>
<h2 id="5、Zookeeper中的领导者选举的流程是怎样的？"><a href="#5、Zookeeper中的领导者选举的流程是怎样的？" class="headerlink" title="5、Zookeeper中的领导者选举的流程是怎样的？"></a>5、Zookeeper中的领导者选举的流程是怎样的？</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211110195621180.png" alt="image-20211110195621180"></p>
<h2 id="6、Zookeeper集群中节点之间数据如何同步"><a href="#6、Zookeeper集群中节点之间数据如何同步" class="headerlink" title="6、Zookeeper集群中节点之间数据如何同步"></a>6、Zookeeper集群中节点之间数据如何同步</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211110202814095.png" alt="image-20211110202814095"></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1、Kafka、ActiveMQ、RabbitMQ、RocketMQ对比"><a href="#1、Kafka、ActiveMQ、RabbitMQ、RocketMQ对比" class="headerlink" title="1、Kafka、ActiveMQ、RabbitMQ、RocketMQ对比"></a>1、Kafka、ActiveMQ、RabbitMQ、RocketMQ对比</h2><p>（1）ActiveMQ: JMS规范,支持事务、支持XA协议,没有生产大规模支撑场景、官方维护越来越少<br>（2）RabbitMQ: erlang语言开发、性能好、高并发，支持多种语言，社区、文档方面有优势，erlang语 言不利于java程序员二次开发，依赖开源社区的维护和升级，需要学习AMQP协议、学习成本相对较高</p>
<p>以上吞吐量单机都在万级<br>（3）kafka:高性能，高可用，生产环境有大规模使用场景，单机容量有限(超过64个分区响应明显变长)、社区更新慢<br>吞吐量单机百万<br>（4）rocketmq: java实现，方便二次开发、 设计参考了kafka,可用、可靠,社区活跃度-般、支持语言较少<br>吞吐量单机十万</p>
<h2 id="2、-Kafka的Pull和Push分别有什么优缺点"><a href="#2、-Kafka的Pull和Push分别有什么优缺点" class="headerlink" title="2、 Kafka的Pull和Push分别有什么优缺点"></a>2、 Kafka的Pull和Push分别有什么优缺点</h2><ol>
<li>pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制,根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空</li>
<li>push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息,消费者就得消费多少消息，所以可能会造成网络堵塞,消费者压勵大等问题</li>
</ol>
<h2 id="3、Kafka高性能高吞吐的原因"><a href="#3、Kafka高性能高吞吐的原因" class="headerlink" title="3、Kafka高性能高吞吐的原因"></a>3、Kafka高性能高吞吐的原因</h2><p>1、磁盘顺序读写:保证了消息的堆积<br>●顺序读写,磁盘会预读,预读即在读取的起始地址连续读取多个页面，主要时间花费在了传输时间，而这个时间两种读写可以认为是一样的。<br>●随机读写，因为数据没有在一起, 将预读浪费掉了。需要多次寻道和旋转延迟。而这个时间可能是传输时间的许多倍。</p>
<p>2、零拷贝:避免CPU将数据从一块存储拷贝到另外一块存储的技术<br>●传统的数据复制:<br>1、读取磁盘文件数据到内核缓冲区<br>2、将内核缓冲区的数据copy到用户缓冲区<br>2、将用户缓冲区的数据copy到socket的发送缓冲区<br>3、将socket发送缓冲区中的数据发送到网卡、进行传输<br>●零拷贝:<br>磁盘文件-&gt;内核空间读取缓冲区-&gt;网卡接口-&gt;消费者进程<br>3、分区分段+索引<br>    Kafka的message消息实际上是分布式存储在一个一个小的segment中的， 每次文件操作也是直接操作的segment。为了进一步的查询优化， Kafka又 默认为分段后的数据文件建立了索引文件，就是文件系统的.index文件。这种分区分段+索引的设计,不仅提升了数据读取的效率,同时也提高了数据操作的并行度<br>4、批量压缩:多条消息一起压缩，降低带宽<br>5、批量读写</p>
<p>6、直接操作page cache，而不是JVM、避免GC耗时及对象创建耗时，且读写速度更高，进程重启、缓存也不会丢失</p>
<h2 id="4、Kafka是pull还是push，优劣势分析"><a href="#4、Kafka是pull还是push，优劣势分析" class="headerlink" title="4、Kafka是pull还是push，优劣势分析"></a>4、Kafka是pull还是push，优劣势分析</h2><p><strong>pull模式:</strong><br>●根据consumer的消费能力进行数据拉取，可以控制速率<br>● 可以批量拉取、也可以单条拉取<br>●可以设置不同的提交方式，实现不同的传输语义<br>缺点:如果kafka没有数据，会导致consumer空循环， 消耗资源<br>解决:通过参数设置，consumer拉取数据为空或者没有达到一-定数量时进行阻塞<br><strong>push模式:不会导致consumer循环等待</strong><br>缺点:速率固定、忽略了consumer的消费能力，可能导致拒绝服务或者网络拥塞等情况</p>
<p><strong>生产者使用push模式将消息发布到Broker，消费者使用pull模式从Broker订阅消息。</strong></p>
<h2 id="5、kafka为什么比RocketMQ的吞吐量要高"><a href="#5、kafka为什么比RocketMQ的吞吐量要高" class="headerlink" title="5、kafka为什么比RocketMQ的吞吐量要高"></a>5、kafka为什么比RocketMQ的吞吐量要高</h2><p>​    Kafka的生产者采用的是异步发送消息机制，当发送一条消息时， 消息并没有发送到Broker而是缓存起来,然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io,从而提高了消息发送的吞吐量，但如果消息生产者宕机，会导致消息失,业务出错,所以理论上kafka利用此机制提高了性能却降低了可靠性。</p>
<h2 id="6、kafka消息丢失的场景以及解决方案"><a href="#6、kafka消息丢失的场景以及解决方案" class="headerlink" title="6、kafka消息丢失的场景以及解决方案"></a>6、kafka消息丢失的场景以及解决方案</h2><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211110215647344.png" alt="image-20211110215647344"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211110220313165.png" alt="image-20211110220313165"></p>
<h2 id="7、MQ有什么用，有哪些具体的使用场景"><a href="#7、MQ有什么用，有哪些具体的使用场景" class="headerlink" title="7、MQ有什么用，有哪些具体的使用场景"></a>7、MQ有什么用，有哪些具体的使用场景</h2><p>MQ: MessageQueue, 消息队列。队列是一 种FIFO先进先出的数据结构。 消息由生产者发送到MQ进行排队，然后由消费者对消息进行处理。QQ、微信 就是典型的MQ场景。<br>MQ的作用主要有三个方面:<br>1、异步:<br>例子:快递。快递员-&gt; 菜鸟驿站&lt;-客户<br>作用:异步能提高系统的响应速度和吞吐量。<br>2、解耦:<br>例子:《Thinking in java》-&gt; 编辑社</p>
<p>作用：服务之间进行解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性</p>
<p>另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者处理</p>
<p>3、削峰</p>
<p>例子:长江涨水-&gt;三峡大坝<br>作用:以稳定的系统资源应对突发的流量冲击。</p>
<p>MQ缺点：</p>
<p>1、系统可用性降低: 一旦MQ宕机，整个业务就会产生影响。高可用<br>2、系统的复杂度提高:引入MQ之后， 数据链路就会变得很复杂。如何保证消息不丢失?消息不会重复调用?怎么保证消息的顺序性?、</p>
<p>3、数据一致性：A系统发消息，需要由B、C两个系统一同处理，如果B系统处理成功，C系统处理失败，就会造成数据一致性问题</p>
]]></content>
      <categories>
        <category>【面试】</category>
      </categories>
      <tags>
        <tag>【Java】</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka学习笔记</title>
    <url>/2021/10/25/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>​    kafka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域</p>
<h3 id="1-2-消息队列"><a href="#1-2-消息队列" class="headerlink" title="1.2 消息队列"></a>1.2 消息队列</h3><h4 id="1-2-1-消息队列的应用场景"><a href="#1-2-1-消息队列的应用场景" class="headerlink" title="1.2.1 消息队列的应用场景"></a>1.2.1 消息队列的应用场景</h4><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019132724762.png" alt="image-20211019132724762"></p>
<p>使用消息队列的好处：  </p>
<p>（1）解耦：</p>
<p>​    允许独立的扩展或修改两边的处理过程，只要保证它们遵守同样的接口约束 </p>
<p>（2）可恢复性：</p>
<p>​    系统的一部分组件失效，不影响整个系统</p>
<p>（3）缓冲：</p>
<p>​    有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况（生产&gt;消费）</p>
<p>（4）灵活性&amp;峰值处理能力（削峰）：</p>
<p>​    访问量剧增的情况下，应用仍需继续发挥作用。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃</p>
<p>（5）异步通信：</p>
<p>​    消息队列提供异步处理机制，允许用户把一个消息放入队列，但并不立即处理。</p>
<h4 id="1-2-2-消息队列的两种模式"><a href="#1-2-2-消息队列的两种模式" class="headerlink" title="1.2.2 消息队列的两种模式"></a>1.2.2 消息队列的两种模式</h4><p>（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</p>
<p>（2）发布/订阅模式（一对多，消费者消费数据之后不会清除消息）</p>
<p>​    消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息，和点对点方式不同，发布到topic的消息会被所有订阅者消费</p>
<p>![image-20211019133619513](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211019133619513.png)</p>
<h3 id="1-3-kafka基础架构"><a href="#1-3-kafka基础架构" class="headerlink" title="1.3 kafka基础架构"></a>1.3 kafka基础架构</h3><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019150922580.png" alt="image-20211019150922580"></p>
<h2 id="二、kafka快速入门"><a href="#二、kafka快速入门" class="headerlink" title="二、kafka快速入门"></a>二、kafka快速入门</h2><h3 id="2-1-搭建集群"><a href="#2-1-搭建集群" class="headerlink" title="2.1 搭建集群"></a>2.1 搭建集群</h3><p>（1）官网地址：kafka.apache.org</p>
<p>下载 0.11.0</p>
<p>（2）解压到/opt/software </p>
<p>​    tar zxvf kafka_2.11-0.11.0.0.tgz</p>
<p>(3)改名 mv </p>
<p>​    mv kafka_2.11-0.11.0.0 kafka</p>
<p>（4）修改config下的server.properties文件，修改四项内容</p>
<p>![image-20211019154945056](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211019154945056.png)</p>
<p>修改id，不能重复，本次使用0 ，1，2</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019154423982.png" alt="image-20211019154423982"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019154403179.png" alt="image-20211019154403179"></p>
<p>/opt/software/kafka/logs</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019154311710.png" alt="image-20211019154311710"></p>
<p>192.168.33.12:2181,192.168.33.13:2181,192.168.33.14:2181</p>
<p>在kafka下创建logs目录 </p>
<p>mkdir logs</p>
<p>（5）使用写好的脚本启动zk集群</p>
<p>./zk.sh start</p>
<p>（6）启动</p>
<p>bin/kafka-server-start.sh -daemon config/server.properties</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019155613032.png" alt="image-20211019155613032"></p>
<p>群起脚本</p>
<p>shell脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line"></span><br><span class="line">"start")&#123;</span><br><span class="line">	for i in 192.168.33.12 192.168.33.13 192.168.33.14</span><br><span class="line">	do</span><br><span class="line">			echo ---------------- kafka $i 启动 ------------</span><br><span class="line">			ssh $i "/opt/software/kafka/bin/kafka-server-start.sh -daemon /opt/software/kafka/config/server.properties"</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">"stop")&#123;</span><br><span class="line">	for i in 192.168.33.12 192.168.33.13 192.168.33.14</span><br><span class="line">	do</span><br><span class="line">			echo ---------------- kafka $i 停止 ------------</span><br><span class="line">			ssh $i "/opt/software/kafka/bin/kafka-server-stop.sh /opt/software/kafka/config/server.properties"</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="2-2-命令"><a href="#2-2-命令" class="headerlink" title="2.2 命令"></a>2.2 命令</h3><p>（1）创建主题</p>
<p>bin/kafka-topics.sh –create –zookeeper 192.168.33.12:2181 –topic first  –partitions 2 –replication-factor 2</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019161427213.png" alt="image-20211019161427213"></p>
<p>（2）查看主题</p>
<p>bin/kafka-topics.sh –list –zookeeper 192.168.33.12:2181</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211019161440493.png" alt="image-20211019161440493"></p>
<p>（3）删除</p>
<p>bin/kafka-topics.sh –delete –zookeeper 192.168.33.12:2181 –topic first</p>
<p>![image-20211019190227449](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211019190227449.png)</p>
<p>(4)查看信息</p>
<p>bin/kafka-topics.sh –describe –topic first –zookeeper 192.168.33.12:2181</p>
<p>![image-20211019190521194](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211019190521194.png)</p>
<p>注意副本数不能超过broker数，分区数不受限制</p>
<p>（5）生产消息</p>
<p>bin/kafka-console-producer.sh –topic first –broker-list 192.168.33.12:9092</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025170215428.png" alt="image-20211025170215428"></p>
<p>（6）建立消费者消费消息（zookeeper老版本）</p>
<p>bin/kafka-console-consumer.sh –topic first –zookeeper 192.168.33.12:2181</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025152057281.png" alt="image-20211025152057281">此时可能会报kafka.consumer.ConsumerFetcherManager$LeaderFinderThread错误</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025170252571.png" alt="image-20211025170252571"></p>
<p>到config中 修改server.properties 将advertised.listeners中的host修改为自己的ip地址，集群内的所有机器都要修改，即可解决该问题</p>
<p>![image-20211025170414645](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211025170414645.png)</p>
<p>生产者发送消息后，消费者即可拿到消息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025170330958.png" alt="image-20211025170330958"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025170339918.png" alt="image-20211025170339918"></p>
<p>最新方式启动</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025171108866.png" alt="image-20211025171108866"></p>
<h2 id="三、Kafka架构深入"><a href="#三、Kafka架构深入" class="headerlink" title="三、Kafka架构深入"></a>三、Kafka架构深入</h2><h3 id="3-1-工作流程及文件存储机制"><a href="#3-1-工作流程及文件存储机制" class="headerlink" title="3.1 工作流程及文件存储机制"></a>3.1 工作流程及文件存储机制</h3><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025210815632.png" alt="image-20211025210815632">    Kafka中消息是以topic进行分类的,生产者生产消息，消费者消费消息，都是面向topic的。<br>    topic是逻辑上的概念，而partition 是物理上的概念，每个partition 对应于一个log文件，该log文件中存储的就是producer生产的数据。Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。消费者组中的每个消费者,都会实时记录自己消费到了哪个offset,以便出错恢复时，从上次的位置继续消费。</p>
<p>​    每个分区都维护独立的偏移量，即Kafka只能保证局部的消息有序，而不能保证全局有序。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025213218142.png" alt="image-20211025213218142"></p>
<p>​    由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制，将每个partition 分为多个segment.每个segment对应两个文件——“.index”文件 和“.1og”文件。这些文件位于一个文件夹下，该文件夹的命名规则为: topic 名称+分区序号。例如，first 这个topic有三个分区，则其对应的文件夹为first-0,first-1 ,first-2。。</p>
<p>​    在server.properties中可以设置一个.log文件最大的大小，默认1G，当超过1G后会新建一个.log存储，.log中只存数据，index中存索引</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025213534581.png" alt="image-20211025213534581"></p>
<p>.log命名是当前的偏移量，从哪个开始的</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025214054632.png" alt="image-20211025214054632"></p>
<h3 id="3-2-生产者"><a href="#3-2-生产者" class="headerlink" title="3.2 生产者"></a>3.2 生产者</h3><h4 id="3-2-1分区策略"><a href="#3-2-1分区策略" class="headerlink" title="3.2.1分区策略"></a>3.2.1分区策略</h4><h5 id="3-2-1-1-分区的原因"><a href="#3-2-1-1-分区的原因" class="headerlink" title="3.2.1.1 分区的原因"></a>3.2.1.1 分区的原因</h5><p>（1）方便在集群中扩展,每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了<br>（2）可以提高并发，因为可以以Partition为单位读写了</p>
<h5 id="3-2-1-2-分区的原则"><a href="#3-2-1-2-分区的原则" class="headerlink" title="3.2.1.2 分区的原则"></a>3.2.1.2 分区的原则</h5><p>​    需要将producer发送的数据封装成一个ProducerRecord对象</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211025220104661.png" alt="image-20211025220104661"></p>
<p>（1）指明partition 的情况下，直接将指明的值直接作为partiton 值；<br>（2）没有指明partition 值但有key的情况下，将key的hash 值与topic 的partition数进行取余得到partition 值；<br>（3）既没有partition 值又没有key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与topic 可用的partition 总数取余得到partition值，也就是常说的round-robin 算法。</p>
]]></content>
      <categories>
        <category>【消息队列】</category>
      </categories>
      <tags>
        <tag>【Kafka】</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis配置与使用</title>
    <url>/2021/10/10/Redis%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一-NoSQL数据库"><a href="#一-NoSQL数据库" class="headerlink" title="一.NoSQL数据库"></a>一.NoSQL数据库</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>​    NoSQL是为了解决性能问题</p>
<p>​    (1)解决CPU及内存压力</p>
<p>​    (2)解决IO压力</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211009203858031.png" alt="image-20211009203858031"></p>
<p>​    NoSQL(Not Only SQL)，泛指非关系型数据库，不依赖业务逻辑方式存储，而以简单的k-v方式存储，大大增加数据库的扩展能力</p>
<p>​    (1)不遵循SQL标准</p>
<p>​    (2)不支持ACID(原子性、一致性、隔离性、持久性)</p>
<p>​    (3)远超于SQL的性能</p>
<h3 id="1-2-NoSQL适用场景"><a href="#1-2-NoSQL适用场景" class="headerlink" title="1.2 NoSQL适用场景"></a>1.2 NoSQL适用场景</h3><p>1.对数据高并发的读写</p>
<p>2.海量数据的读写</p>
<p>3.对数据的高可扩展性</p>
<h3 id="1-3-NoSQL不适用场景"><a href="#1-3-NoSQL不适用场景" class="headerlink" title="1.3 NoSQL不适用场景"></a>1.3 NoSQL不适用场景</h3><p>1.需要事务支持</p>
<p>2.基于sql的结构化查询存储，处理复杂的关系，需要即席查询</p>
<p>(用不着sql和用了sql也不行的时候，考虑使用NoSQL)</p>
<h2 id="二、Redis"><a href="#二、Redis" class="headerlink" title="二、Redis"></a>二、Redis</h2><p>1.Redis是一个开源的k-v存储系统</p>
<p>2.支持string、list、set、zset(sorted set — 有序集合)、hash</p>
<p>3.这些数据类型都支持pop/push、add/remove及取交集并集和差集等丰富的操作，而且都是原子操作</p>
<p>4.Redis支持各种不同方式的排序</p>
<p>5.数据缓存在内存中</p>
<p>6.与memcached的区别是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</p>
<p>7.实现了master-slave（主从）同步</p>
<h2 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h2><p>1.官网下载Redis 6.2.1 redis-6.2.1.tar.gz  官网：<a href="https://redis.io/，也可以前往https://download.redis.io/releases/下载" target="_blank" rel="noopener">https://redis.io/，也可以前往https://download.redis.io/releases/下载</a></p>
<p>2.进入/opt目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br></pre></td></tr></table></figure>

<p>3.解压redis-6.2.1.tar.gz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>4.安装c语言环境(已安装可略过)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure>

<p>测试gcc版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010202134794.png" alt="image-20211010202134794"></p>
<p>5.进入 redis-6.2.1目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.1</span><br></pre></td></tr></table></figure>

<p>6.编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>7.执行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010202651293.png" alt="image-20211010202651293"></p>
<p>8.进入bin目录，使用前台启动测试安装是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010203010224.png" alt="image-20211010203010224"></p>
<p>出现这个界面就算成功了，使用control+c停止redis进程</p>
<p>9.设置后台启动</p>
<p>(1)进入 redis-6.2.1目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/redis-6.2.1</span><br></pre></td></tr></table></figure>

<p>(2)复制redis.conf文件到/etc目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br></pre></td></tr></table></figure>

<p>(3)进入/etc文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc</span><br></pre></td></tr></table></figure>

<p>(4)修改 redis.conf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure>

<p>(5)后台启动设置daemonize no改为yes，可以打/dae搜索到这个语句</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010204625406.png" alt="image-20211010204625406"></p>
<p>找到 daemonize no 改为yes</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010204811127.png" alt="image-20211010204811127"></p>
<p>保存修改</p>
<p>(6)进入 /usr/local/bin目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>（7）输入 redis-server /etc/redis.conf后台启动redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010205124156.png" alt="image-20211010205124156"></p>
<p>此时可以输入redis-cli可以客户端访问</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010205256276.png" alt="image-20211010205256276"></p>
<p>输入ping，返回PONG说明已经正常连接</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010205403233.png" alt="image-20211010205403233"></p>
<p>(8)在redis-cli状态下，输入shutdown可以关闭redis</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211010205519946.png" alt="image-20211010205519946"></p>
<h2 id="四、Redis相关知识"><a href="#四、Redis相关知识" class="headerlink" title="四、Redis相关知识"></a>四、Redis相关知识</h2><p>1.默认有16个数据库，所有库密码相同，默认使用0号库</p>
<p>可以使用select切换数据如，如select 8</p>
<p>可以使用dbsize查看当前数据库的key的数量</p>
<p>flushdb清空当前库</p>
<p>flushall通杀全部库</p>
<p>2.redis是单线程+多路IO复用，memcashed是多线程+锁</p>
<h2 id="五、常用五大数据类型"><a href="#五、常用五大数据类型" class="headerlink" title="五、常用五大数据类型"></a>五、常用五大数据类型</h2><h3 id="5-1-Redis键-key"><a href="#5-1-Redis键-key" class="headerlink" title="5.1 Redis键(key)"></a>5.1 Redis键(key)</h3><p>Keys * 查看当前库所有key</p>
<p>set [key] [value]:设置k-v 如 set k1 name</p>
<p>exists [key] 判断key是否存在，返回1存在，返回0不存在</p>
<p>type [key]  查看key是什么类型</p>
<p>del [key] 删除指定的key数据</p>
<p>Unlink [key] 根据value选择非阻塞删除:仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作</p>
<p>expire [key] [time]:为给定的key设定过期时间，以秒为单位</p>
<p>ttl [key]查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<h3 id="5-2-字符串String"><a href="#5-2-字符串String" class="headerlink" title="5.2 字符串String"></a>5.2 字符串String</h3><p>​    Redis的String类型是最基本的数据类型，一个字符串value值最多可以使512M，同时String是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象</p>
<p>操作:</p>
<p>(1)set [key] [value]:设置k-v 如 set k1 name</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011144731620.png" alt="image-20211011144731620"></p>
<p>(2)get [key]:获取该key对应的value</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011144813377.png" alt="image-20211011144813377"></p>
<p>(3)append [key] [value]:向key对应的value后追加值，同时返回长度，若key不存在，则新建</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011144942354.png" alt="image-20211011144942354"></p>
<p>(4)strlen [key]:获取长度</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145103816.png" alt="image-20211011145103816"></p>
<p>(5)setnx [key] [value]:只有key不存在时，才设置key的值</p>
<p>key1存在，所以无法设置成功</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145412074.png" alt="image-20211011145412074"></p>
<p>key2不存在，成功设置</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145433099.png" alt="image-20211011145433099"></p>
<p>(6) incr [key]:将key中存储的数字值增加1，只能对数字操作</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145645507.png" alt="image-20211011145645507"></p>
<p>当key不存在时，新建并值为1</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145719568.png" alt="image-20211011145719568"></p>
<p>(7)decr [key]:将key中存储的数字值减1</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145743593.png" alt="image-20211011145743593"></p>
<p>如果key不存在，新建并值为-1</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011145820299.png" alt="image-20211011145820299"></p>
<p>(8)incrby [key] [步长]:将key中存储的数字值增加，自定义步长，如果步长为20则值增加20</p>
<p>(9)decrby [key] [步长]:将key中存储的数字值减少，自定义步长，如果步长为20则值减少20</p>
<h3 id="5-3-列表List"><a href="#5-3-列表List" class="headerlink" title="5.3 列表List"></a>5.3 列表List</h3><p>​    List是单键多值的数据类型，按照插入顺序排序。可以添加一个元素到列表的头部或者尾部。其底层是双向链表。</p>
<p>操作：</p>
<p>（1）lpush/rpush [key] [value1] [value2]……：从左边/右边插入一个或多个值</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011195152155.png" alt="image-20211011195152155"></p>
<p>（2）Irange [key] [start] [stop]：按照索引下表获得元素(从左到右)，如果输入的start和stop分别是0和-1则表示取所有值</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011195419315.png" alt="image-20211011195419315"></p>
<p>（3）lpop/rpop [key]：从左边/右边弹出一个值，当值全部弹出，键自动删除</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011195517596.png" alt="image-20211011195517596"></p>
<p>（4）rpoplpush [key1] [key2]：从key1列表右边弹出一个值，插入到key2列表的左边</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011195733955.png" alt="image-20211011195733955"></p>
<p>（5）lindex [key] [index]：按照索引下表获取指定元素（从左到右）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011195804261.png" alt="image-20211011195804261"></p>
<p>（6）linsert [key] before [value] [newvalue]：在[value]前面插入[newvalue]</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200008482.png" alt="image-20211011200008482"></p>
<p>（7）lrem [key] [n] [value]：从左边删除n个value</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200033824.png" alt="image-20211011200033824"></p>
<p>（8）lset [key] [index] [value]：将列表key下标为index的值替换成value</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200105459.png" alt="image-20211011200105459"></p>
<h3 id="5-4-Redis集合Set"><a href="#5-4-Redis集合Set" class="headerlink" title="5.4 Redis集合Set"></a>5.4 Redis集合Set</h3><p>​    Redis中的集合也是类似于列表的功能，但是set中不允许存在重复元素，其实string类型的无需集合，底层为哈希表，添加、删除、查找的复杂度都是O(1)</p>
<p>操作：</p>
<p>（1）sadd [key] [value1] [value2]：将一个或多个元素加入到key中，自动排重</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200737962.png" alt="image-20211011200737962"></p>
<p>（2）smembers [key]：查看集合中所有值</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200753596.png" alt="image-20211011200753596"></p>
<p>（3）sismember [key] [value]：判断集合key是否含有给定value值，有返回1，没有返回0</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200835616.png" alt="image-20211011200835616"></p>
<p>（4）scard [key]：返回该集合的元素个数</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200859899.png" alt="image-20211011200859899"></p>
<p>（5）srem [key] [value1] [value2]：删除集合中的某个元素</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011200914762.png" alt="image-20211011200914762"></p>
<p>（6）spop [key]：随机从集合中弹出一个值</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201015679.png" alt="image-20211011201015679"></p>
<p>（7）srandmember [key] [n]：随机从集合中取出n个值，不从集合中删除这些值</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201050295.png" alt="image-20211011201050295"></p>
<p>（8）smove [source] [destination] [value]：把集合中的一个值移动到另一个集合</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201421546.png" alt="image-20211011201421546"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201421546.png" alt=""></p>
<p>（9）sinter [key1] [key2]： 返回两个集合的交集</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201558700.png" alt="image-20211011201558700"></p>
<p>（10）sunion [key1] [key2]： 返回两个集合的并集</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201616779.png" alt="image-20211011201616779"></p>
<p>（11）sdiff [key1] [key2]： 返回两个集合的差集（key1中的，不包含key2中的）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011201632139.png" alt="image-20211011201632139"></p>
<h3 id="5-5-Redis哈希Hash"><a href="#5-5-Redis哈希Hash" class="headerlink" title="5.5 Redis哈希Hash"></a>5.5 Redis哈希Hash</h3><p>​    Redis中的hash是一个string类型的field和value的映射表，适合用于存储对象，类似java中的Map&lt;String,Object&gt;，其底层当field-value长度较短且个数较少时，会使用ziplist（压缩列表），否则使用hashtable（hash表）</p>
<p>操作：</p>
<p>（1）hset [key] [field] [value]：给key集合中的field键赋值value</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203250489.png" alt="image-20211011203250489"></p>
<p>（2）hget [key] [field]：从key1集合filed取出value</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203318971.png" alt="image-20211011203318971"></p>
<p>（3）hmset [key1] [field1] [value1] [field2] [value2]：批量设置hash的值（新版本hset也可以实现该功能）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203401641.png" alt="image-20211011203401641"></p>
<p>（4）hexists [key1] [field]：查看哈希表key中，给定域field是否存在</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203453362.png" alt="image-20211011203453362"></p>
<p>（5）hkeys [key]：列出该hash集合的所有field</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203514471.png" alt="image-20211011203514471"></p>
<p>（6）hvals [key]：列出该hash集合的所有value</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203526640.png" alt="image-20211011203526640"></p>
<p>（7）hincrby [key] [field] [increment]：为哈希表key中的域field的值加上增量</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203705135.png" alt="image-20211011203705135"></p>
<p>（8）hsetnx [key] [field] [value]：将哈希表key中的域field的值设为value，当且仅当域field不存在时才能成功操作</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011203811372.png" alt="image-20211011203811372"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011204000283.png" alt="image-20211011204000283"></p>
<h3 id="5-6-Redis有序集合Zset"><a href="#5-6-Redis有序集合Zset" class="headerlink" title="5.6 Redis有序集合Zset"></a>5.6 Redis有序集合Zset</h3><p>​    Zset也是一个没有重复元素的集合，与set的不同是Zset的每个成员都关联了一个评分，按照评分从低到高排序集合中的成员，评分可以重复。</p>
<p>​    其底层使用了两个数据结构:</p>
<p>​    （1）哈希表，作用是关联value和score，保障元素的唯一性</p>
<p>​    （2）跳跃表，作用是给value排序，根据score的饭味获取元素列表</p>
<p>操作：</p>
<p>（1）zadd [key] [score1] [value1] [score2] [value2]：将一个或多个member元素及其值加入到key中</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011204731380.png" alt="image-20211011204731380"></p>
<p>（2）zrange [key] [start] [end] [WITHSCORES]：返回下表在start和end之间的元素，如果带上WITHSCORES，可以将分数一起返回，如果start和end分别是0，-1，则返回全部元素</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011204831112.png" alt="image-20211011204831112"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011204852149.png" alt="image-20211011204852149"></p>
<p>（3）zrangebyscore [key] [min] [max] [withscores] [limit offset count]：返回所有score值介于min和max之间（闭区间）的成员，按score从小到大排列，limit offset count是分页</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011204952952.png" alt="image-20211011204952952"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011205014351.png" alt="image-20211011205014351"></p>
<p>（4）zrevrangebyscore [key] [max] [min] [withscores] [limit offset count]：返回所有score值介于min和max之间（闭区间）的成员，按score从大到小排列</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011205143520.png" alt="image-20211011205143520"></p>
<p>（5）zincrby [key] [increment] [value]：为元素的score加上增量</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011205432322.png" alt="image-20211011205432322"></p>
<p>（6）zrem [key] [value]：删除指定值的元素</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011205458082.png" alt="image-20211011205458082">（7）zcount [key] [min] [max]：统计区间内的元素个数（闭区间）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011205522605.png" alt="image-20211011205522605"></p>
<p>（8）zrank [key] [value]：返回指定值在集合中的排名，从0开始</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211011205604287.png" alt="image-20211011205604287"></p>
<h2 id="六、配置文件"><a href="#六、配置文件" class="headerlink" title="六、配置文件"></a>六、配置文件</h2><h3 id="6-1-Units单位"><a href="#6-1-Units单位" class="headerlink" title="6.1 Units单位"></a>6.1 Units单位</h3><p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012140900501.png" alt="image-20211012140900501"></p>
<p>配置大小单位，定义了一些基本的度量单位，只支持Bytes，不支持bit</p>
<h3 id="6-2-INCLUDES"><a href="#6-2-INCLUDES" class="headerlink" title="6.2 INCLUDES"></a>6.2 INCLUDES</h3><p>设置包含的其他配置信息，比如有些公共部分，可以设置包含来配置</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012141103389.png" alt="image-20211012141103389"></p>
<h3 id="6-3-网络配置"><a href="#6-3-网络配置" class="headerlink" title="6.3 网络配置"></a>6.3 网络配置</h3><p>（1）bind</p>
<p>如果设置的是127.0.0.1，表示只能本地连接，不能通过其他设备进行远程连接</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012141424427.png" alt="image-20211012141424427">（2）保护模式</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012141623050.png" alt="image-20211012141623050"></p>
<p>protected-mode yes表示开启保护模式，当没有设置密码时也是保证不可以远程连接</p>
<p>注释bind，将保护模式关闭，表示没设置密码也可以开放远程连接</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012141513835.png" alt="image-20211012141513835"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012141727798.png" alt="image-20211012141727798"></p>
<p>（3）端口号</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012141925095.png" alt="image-20211012141925095"></p>
<p>（4）tcp-backlog</p>
<p>用来设置tcp的backlog，backlog是一个连接队列，backlog队列总和=未完成三次握手的队列+已完成三次握手队列</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012144442489.png" alt="image-20211012144442489"></p>
<p>（5）timeout</p>
<p>超时时间，以秒为单位，表示多长时间未操作就断开连接，如果是0表示永不超时</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012145032224.png" alt="image-20211012145032224"></p>
<p>（6）tcp-keepalvie</p>
<p>tcp长链接保持时间，检测连接是否还活着，表示发送ACK的间隔时间</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012145143788.png" alt="image-20211012145143788"></p>
<p>（7）pidfile</p>
<p>存放pid文件的位置，每个实例会产生不同的pid文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012145626800.png" alt="image-20211012145626800"></p>
<p>（8）日志级别</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012145734140.png" alt="image-20211012145734140"></p>
<p>分为四种级别</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012145747380.png" alt="image-20211012145747380"></p>
<p>debug:开发环境中使用，看到更加详细的信息</p>
<p>verbose:看到有用的信息，但是没有debug那么详细</p>
<p>notice:生产环境使用</p>
<p>warning:只会看到特别重要的信息</p>
<p>（9）日志输出目录</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012145946895.png" alt="image-20211012145946895"></p>
<p>设置日志的输出目录</p>
<p>（10）databases</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211012150109822.png" alt="image-20211012150109822"></p>
<p>默认的16个库</p>
<h2 id="七、Redis6新数据类型"><a href="#七、Redis6新数据类型" class="headerlink" title="七、Redis6新数据类型"></a>七、Redis6新数据类型</h2><h3 id="7-1-Bitmaps"><a href="#7-1-Bitmaps" class="headerlink" title="7.1 Bitmaps"></a>7.1 Bitmaps</h3><p>TODO</p>
<h3 id="八、Redis案例"><a href="#八、Redis案例" class="headerlink" title="八、Redis案例"></a>八、Redis案例</h3><p>1.输入手机号，点击后发送随机生成6位数字码，两分钟有效</p>
<p>2.输入验证码，点击验证，返回成功或者失败</p>
<p>3.每个手机号每天只能输入3次</p>
<h2 id="九、Redis与SpringBoot整合"><a href="#九、Redis与SpringBoot整合" class="headerlink" title="九、Redis与SpringBoot整合"></a>九、Redis与SpringBoot整合</h2><h2 id="十、Redis6的事务操作"><a href="#十、Redis6的事务操作" class="headerlink" title="十、Redis6的事务操作"></a>十、Redis6的事务操作</h2><h3 id="10-1-Redis的事务定义"><a href="#10-1-Redis的事务定义" class="headerlink" title="10.1 Redis的事务定义"></a>10.1 Redis的事务定义</h3><p>​    Redis事务是一个单独的隔离操作，事务总的所有命令都会序列化、按顺序地执行。事务在执行过程中，不会被其他客户端发来的命令所打断。</p>
<p>​    Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h3 id="10-2-Multi、Exec、Discard"><a href="#10-2-Multi、Exec、Discard" class="headerlink" title="10.2 Multi、Exec、Discard"></a>10.2 Multi、Exec、Discard</h3><p>​    从输入Multi命令开始，输入的命令都会依次进入命令队列，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行，组队的过程中可以通过discard放弃组队。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013140016209.png" alt="image-20211013140016209"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013140327491.png" alt="image-20211013140327491"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013140308142.png" alt="image-20211013140308142"></p>
<h3 id="10-3-事务错误处理"><a href="#10-3-事务错误处理" class="headerlink" title="10.3 事务错误处理"></a>10.3 事务错误处理</h3><p>​    组队中某个命令出错，在执行时整个队列命令都会取消</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013140548978.png" alt="image-20211013140548978"></p>
<p>在执行阶段某个命令出错，则只有报错的命令不会被执行，其他的命令正常执行</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013140748573.png" alt="image-20211013140748573"></p>
<p>由于设置的k1的value并不是数字，导致incr自增失败</p>
<h3 id="10-4-锁"><a href="#10-4-锁" class="headerlink" title="10.4 锁"></a>10.4 锁</h3><p>（1）悲观锁</p>
<p>​    悲观锁是认为数据在共享前会出现线程安全问题，所以先上锁，其他人想使用这个数据就要先等待锁释放。传统的关系型数据库用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等。这种方式效率很低</p>
<p> <img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013141349983.png" alt="image-20211013141349983"></p>
<p>（2）乐观锁</p>
<p>​    乐观锁，每次拿数据时都认为别人不会修改，所以不上锁，但是在更新的时候会判断此期间有没有别人更新过这个数据，可以使用版本号等机制。乐观锁适用于多度的应用类型，可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013142341060.png" alt="image-20211013142341060"></p>
<p>在两个终端上进行一次乐观锁的测试，两个终端都watch balance，之后终端1对balance进行加10操作并加入事务队列，终端2对balance进行加20操作，并加入事务队列，终端1先执行了事务，成功加10，终端2再执行无效</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013171133390.png" alt="image-20211013171133390"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211013171327875.png" alt="image-20211013171327875"></p>
<p>使用unwatch命令可以取消监视</p>
<h3 id="10-5-Redis事务三特性"><a href="#10-5-Redis事务三特性" class="headerlink" title="10.5 Redis事务三特性"></a>10.5 Redis事务三特性</h3><p>（1）单独的隔离操作：</p>
<p>​    Redis事务是一个单独的隔离操作，事务总的所有命令都会序列化、按顺序地执行。事务在执行过程中，不会被其他客户端发来的命令所打断。</p>
<p>（2）没有隔离级别的概念：</p>
<p>​    队列中的命令在没有提交之前不会被执行</p>
<p>（3）不保证原子性</p>
<p>​    事务中如果有一条命令执行失败，其他的命令仍会执行，没有回滚</p>
<h2 id="十一、Redis持久化"><a href="#十一、Redis持久化" class="headerlink" title="十一、Redis持久化"></a>十一、Redis持久化</h2><h3 id="11-1-RDB（Redis-DataBase）"><a href="#11-1-RDB（Redis-DataBase）" class="headerlink" title="11.1 RDB（Redis DataBase）"></a>11.1 RDB（Redis DataBase）</h3><h4 id="11-1-1-概念"><a href="#11-1-1-概念" class="headerlink" title="11.1.1 概念"></a>11.1.1 概念</h4><p>​    RDB指在指定的时间间隔将内存中的数据集快照写入磁盘，恢复时是将快照文件直接读取到内存里</p>
<h4 id="11-1-2-备份如何执行"><a href="#11-1-2-备份如何执行" class="headerlink" title="11.1.2 备份如何执行"></a>11.1.2 备份如何执行</h4><p>​    Redis会单独创建(fork)一个子进程来进行持久化，先将数据写入到一个临时文件中，等持久化进程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程不进行任何IO操作，如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014143112600.png" alt="image-20211014143112600"></p>
<h4 id="11-1-3-Fork"><a href="#11-1-3-Fork" class="headerlink" title="11.1.3 Fork"></a>11.1.3 Fork</h4><p>​    Fork的作用是复制一个与当前进程一样的进程。 新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致,但是是一个全新的进程,并作为原进程的子进程。</p>
<p>​    在Linux程序中, fork()会产生一个 和父进程完全相同的子进程,但子进程在此后多会exec系统调用,出于效率考虑, Linux中引入了”写时复制技术”</p>
<p>​    一般情况父进程和子进程会共用同一段物理内存,只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
<h4 id="11-1-4-dump-rdb文件"><a href="#11-1-4-dump-rdb文件" class="headerlink" title="11.1.4 dump.rdb文件"></a>11.1.4 dump.rdb文件</h4><p>​    可以在redis.conf中配置文件名称，默认为dump.rdb，通过vi打开配置文件，输入/dbfilename可以搜索到这条配置信息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014143359143.png" alt="image-20211014143359143"></p>
<p>下方的dir表示文件生成在哪个目录，./表示生成在启动目录下</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014143538619.png" alt="image-20211014143538619"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014143653960.png" alt="image-20211014143653960"></p>
<p>stop-writes-on-bgsave-error表示当Redis无法写入磁盘时，比如硬盘已经满了等情况，直接关闭Redis的写操作，推荐使用yes</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014143857766.png" alt="image-20211014143857766"></p>
<p> rdbcompression表示设置对存储到磁盘中的快照是否压缩存储，如果yes则使用LZF算法进行压缩</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014144204287.png" alt="image-20211014144204287"></p>
<p>rdbchecksum表示进行完整性检查，在存储快照后，redis使用CRC64算法来进行数据校验，但是会增加大约10%的性能消耗</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014144027525.png" alt="image-20211014144027525"></p>
<p>save是用来在指定的时间间隔内将内存中的数据集快照写入磁盘，格式为 save 秒 写操作次数</p>
<p>默认有三种，第一种是15分钟内做了一次修改操作，第二种是在五分钟内做了五次修改操作，第三种是一分钟内做了一万次修改操作。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014194957728.png" alt="image-20211014194957728"></p>
<p>如设置save 20 3，则表示在20秒内做了3次修改操作会自动将数据集快照写入磁盘</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014195156104.png" alt="image-20211014195156104"></p>
<p>注释save指令或给save传入空字符串都可以禁用</p>
<h4 id="11-1-5-RDB优势"><a href="#11-1-5-RDB优势" class="headerlink" title="11.1.5 RDB优势"></a>11.1.5 RDB优势</h4><p>（1）适合大规模的数据恢复</p>
<p>（2）对数据完整性和一致性要求不高更适合使用</p>
<p>（3）节省磁盘空间</p>
<p>（4）恢复速度快</p>
<h4 id="11-1-6-劣势"><a href="#11-1-6-劣势" class="headerlink" title="11.1.6 劣势"></a>11.1.6 劣势</h4><p>（1）Fork会克隆一份内存中的数据，体积会膨胀2倍</p>
<p>（2）虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大会十分消耗性能</p>
<p>（3）如果redis意外down掉，会丢失最后一次快照后的所有修改：因为save操作是在一定时间间隔内做多少次操作才会触发，如果在时间段内的操作还没有达到设定的次数就崩溃了，会导致本次的所有操作没有进行持久化操作，修改就会丢失</p>
<h3 id="11-2-AOF（Append-Of-File）"><a href="#11-2-AOF（Append-Of-File）" class="headerlink" title="11.2 AOF（Append Of File）"></a>11.2 AOF（Append Of File）</h3><h4 id="11-2-1-概念"><a href="#11-2-1-概念" class="headerlink" title="11.2.1 概念"></a>11.2.1 概念</h4><p>​    以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有指令记录下来（读操作不记录），只需追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，即按照文件内容将指令从头到尾执行一遍</p>
<h4 id="11-2-2-AOF持久化流程"><a href="#11-2-2-AOF持久化流程" class="headerlink" title="11.2.2 AOF持久化流程"></a>11.2.2 AOF持久化流程</h4><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内</p>
<p>（2）AOF缓冲区根据AOF持久化策略[always，everysec，no]将操作sync同步到磁盘的AOF文件中</p>
<p>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</p>
<p>（4）Redis服务重启时，会重新Load加载AOF文件中的写操作达到数据恢复的目的</p>
<h4 id="11-2-3-AOF配置"><a href="#11-2-3-AOF配置" class="headerlink" title="11.2.3 AOF配置"></a>11.2.3 AOF配置</h4><p>​    AOF默认不开启，可以在redis.conf中配置文件名称，默认为appendonly.aof，AOF文件的保存路径和RDB的路径一致</p>
<p>​    配置文件中默认为no，文件名称默认为appendonly.aof</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014204703083.png" alt="image-20211014204703083"></p>
<p>将其改为yes，则开启AOF</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014204808472.png" alt="image-20211014204808472"></p>
<p>重启redis后，可以看到生成了对应文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014204931434.png" alt="image-20211014204931434"></p>
<p>​    当AOF和RDB同时开启时，系统会默认取AOF的数据</p>
<h4 id="11-2-4-异常恢复"><a href="#11-2-4-异常恢复" class="headerlink" title="11.2.4 异常恢复"></a>11.2.4 异常恢复</h4><p>​    如果AOF文件意外损坏，可以通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复</p>
<p>​    用vi命令打开appendonly.aof文件并在其后随便追加一个无用信息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014205624208.png" alt="image-20211014205624208"></p>
<p>​    重新启动redis后，启动客户端失败，因为无法正确读取AOF文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014205714951.png" alt="image-20211014205714951"></p>
<p>此时输入上述命令对aof文件进行修复</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014205807962.png" alt="image-20211014205807962"></p>
<p>此时，正确连接并成功读取数据</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014205847537.png" alt="image-20211014205847537"></p>
<h4 id="11-2-5-AOF同步频率设置"><a href="#11-2-5-AOF同步频率设置" class="headerlink" title="11.2.5 AOF同步频率设置"></a>11.2.5 AOF同步频率设置</h4><p>​    同步频率设置分为三种</p>
<p>（1）appendfsync always：</p>
<p>​    表示始终同步，每次Redis的写入都会立刻记入日志，性能较差但是数据完整性比较好</p>
<p>（2）appendfsync evverysec</p>
<p>​    每秒同步，每秒计入日志一次，如果此时崩溃，可能会丢失本秒的数据</p>
<p>（3）appendfsync no</p>
<p>​    不主动同步，把同步时机交给操作系统</p>
<p>![image-20211014210243169](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211014210243169.png)</p>
<h4 id="11-2-6-Rewrite压缩"><a href="#11-2-6-Rewrite压缩" class="headerlink" title="11.2.6 Rewrite压缩"></a>11.2.6 Rewrite压缩</h4><p>​    AOF采用文件追加方式,文件会越来越大为避免出现此种情况,新增了重写机制，当AOF文件的大小超过所设定的阈值时, Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaofs</p>
<p>​    AOF文件持续增长而过大时，会fork出一条新进程来将文件重写( 也是先写临时文件最后再rename) ，redis4.0版本后的重写，就是把rdb的快照，以二进制的形式附在新的aof头部，作为已有的历史数据,替换掉原来的流水账操作。</p>
<h4 id="11-2-7-优势"><a href="#11-2-7-优势" class="headerlink" title="11.2.7 优势"></a>11.2.7 优势</h4><p>（1）备份机制更稳健，丢失数据概率更低</p>
<p>（2）可读的日志文本，通过操作AOF文件，可以处理误操作</p>
<h4 id="11-2-8-劣势"><a href="#11-2-8-劣势" class="headerlink" title="11.2.8 劣势"></a>11.2.8 劣势</h4><p>（1）比起RDB占用空间更大</p>
<p>（2）恢复备份速度慢</p>
<p>（3）每次读写都同步的话，性能压力大</p>
<h3 id="11-3-总结"><a href="#11-3-总结" class="headerlink" title="11.3 总结"></a>11.3 总结</h3><p>如果对数据不敏感，可以单独选用RDB</p>
<p>不建议单独启用AOF，可能会出现BUG</p>
<p>如果仅仅做纯内存缓存，可以都不用</p>
<h2 id="十二、主从复制"><a href="#十二、主从复制" class="headerlink" title="十二、主从复制"></a>十二、主从复制</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><p>​    主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<h3 id="12-2-作用"><a href="#12-2-作用" class="headerlink" title="12.2 作用"></a>12.2 作用</h3><p>（1）读写分离，扩展性能</p>
<p>（2）抗灾性强，快速恢复</p>
<h3 id="12-3-模拟搭建一主二从"><a href="#12-3-模拟搭建一主二从" class="headerlink" title="12.3 模拟搭建一主二从"></a>12.3 模拟搭建一主二从</h3><p>（1）在根目录下创建myredis目录，并进入目录</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014214114849.png" alt="image-20211014214114849"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014214124725.png" alt="image-20211014214124725"></p>
<p>（2）复制/etc/redic.conf到/myredis/redis.conf</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014214222061.png" alt="image-20211014214222061"></p>
<p>（3）创建三个配置文件，分别命名redis6379.conf、redis6380.conf、redis6381.conf，并通过include引入共同配置文件redis.conf，同时进行对应配置信息的修改</p>
<p>首先通过vi创建并修改redis6379.conf配置文件的内容</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014214736262.png" alt="image-20211014214736262"></p>
<p>输入以下内容并保存退出，表示引入redis.conf，修改pidfile，端口号为6379，修改持久化RDB的文件名称</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014214809319.png" alt="image-20211014214809319"></p>
<p>用相同的方法，创建redis6380.conf，并进行同样的修改</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014214953963.png" alt="image-20211014214953963"></p>
<p>继续配置redis6381.conf</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215050330.png" alt="image-20211014215050330"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215130319.png" alt="image-20211014215130319"></p>
<p>（4）启动三个服务</p>
<p>![image-20211014215242074](/Users/sundaohan/Library/Application Support/typora-user-images/image-20211014215242074.png)</p>
<p>（5）检查服务开启是否成功</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215318875.png" alt="image-20211014215318875"></p>
<p>（6）开启三个终端，分别打开三个服务的客户端</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215620764.png" alt="image-20211014215620764"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215630300.png" alt="image-20211014215630300"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215704640.png" alt="image-20211014215704640"></p>
<p>（7）配置6379为主，其他为从</p>
<p>在6380和6381执行：slaveof 127.0.0.1 6379 该命令格式为:slaveof [ip] [port]</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215843242.png" alt="image-20211014215843242"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014215852327.png" alt="image-20211014215852327"></p>
<p>（8）查看是否配置成功</p>
<p>​    在三个终端分别通过命令info replication查看信息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220032926.png" alt="image-20211014220032926"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220101419.png" alt="image-20211014220101419"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220128045.png" alt="image-20211014220128045"></p>
<p>（9）测试效果</p>
<p>在主机中进行写操作</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220338340.png" alt="image-20211014220338340"></p>
<p>在从机中查看</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220409982.png" alt="image-20211014220409982"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220422877.png" alt="image-20211014220422877"></p>
<p>如果在从机中进行写操作则会报错</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211014220454852.png" alt="image-20211014220454852"></p>
<p>当从服务器挂掉后，重新连接会从头同步数据，如果主服务器挂掉，从服务器不会取代，还是认同之前挂掉的主服务器</p>
<h3 id="12-4-复制原理"><a href="#12-4-复制原理" class="headerlink" title="12.4 复制原理"></a>12.4 复制原理</h3><p>（1）当从连接上主服务器之后，从服务器向主服务器发送进行数据同步消息</p>
<p>（2）主服务器接到从服务器发送来的同步消息，把主服务器数据进行持久化到rdb文件中，把rdb文件发送到从服务器，从服务器拿到rdb进行读取</p>
<p>（3）每次主服务器进行写操作之后，和从服务器进行数据同步</p>
<p>全量复制：slave服务器在接收到数据库文件数据后，将其存盘并加载到内存中</p>
<p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave完成同步</p>
<p>只要重新连接master，一次完全同步将被自动执行</p>
<h3 id="12-5-薪火相传"><a href="#12-5-薪火相传" class="headerlink" title="12.5 薪火相传"></a>12.5 薪火相传</h3><p>​    即层层管理，主服务器挂掉，从服务器也不会上位</p>
<h3 id="12-6-反客为主"><a href="#12-6-反客为主" class="headerlink" title="12.6 反客为主"></a>12.6 反客为主</h3><p>​    主服务器挂了，从服务器自动上位，slaveof no one命令可以手动将从服务器提升为主服务器</p>
<h3 id="12-7-哨兵模式（sentinel）"><a href="#12-7-哨兵模式（sentinel）" class="headerlink" title="12.7 哨兵模式（sentinel）"></a>12.7 哨兵模式（sentinel）</h3><h4 id="12-7-1-概念"><a href="#12-7-1-概念" class="headerlink" title="12.7.1 概念"></a>12.7.1 概念</h4><p>​    是反客为主的自动版，能够后台自动监视主机是否故障，如果故障了根据投票数自动将从机转换为主机</p>
<h4 id="12-7-2-模拟实现"><a href="#12-7-2-模拟实现" class="headerlink" title="12.7.2 模拟实现"></a>12.7.2 模拟实现</h4><p>（1）首先先调整一主二从模式，6379为主，6380、6381为从</p>
<p>（2）在/myredis目录下新建sentinel.conf文件，名字固定</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015142830647.png" alt="image-20211015142830647"></p>
<p>（3）配置哨兵，填写内容</p>
<p>sentinel monitor mymaster 127.0.0.1 6379 1</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015142830647.png" alt="image-20211015142749368"></p>
<p>其中mymaster为监控对象起的服务器名称，1为至少有多少个哨兵同意迁移的数量</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015142845053.png" alt="image-20211015142845053"></p>
<p>（4）启动哨兵</p>
<p>redis-sentinel /myredis/sentinel.conf</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015143018145.png" alt="image-20211015143018145"></p>
<p>（5）关闭主机，查看效果</p>
<p>在6379中输入shutdown关闭服务</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015143734684.png" alt="image-20211015143734684"></p>
<p>可以看到，哨兵选举了6381成为新的主机</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015143936003.png" alt="image-20211015143936003"></p>
<p>到6380和6381查看信息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015144006228.png" alt="image-20211015144006228"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015144019746.png" alt="image-20211015144019746"></p>
<p>可以看到6381已经成为新的主机</p>
<p>（6）重新打开6379，查看信息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015144520932.png" alt="image-20211015144520932"></p>
<h4 id="12-7-3-复制延时"><a href="#12-7-3-复制延时" class="headerlink" title="12.7.3 复制延时"></a>12.7.3 复制延时</h4><p>​    由于所有的写操作都是先在Master上操作,然后同步更新到Slave.上,所以从Master同步到Slave机器有一定的延迟,当系统很繁忙的时候,延迟问题会更加严重, Slave机器数量的增加也会使这个问题更加严重。</p>
<h4 id="12-7-4-新主机选取规则"><a href="#12-7-4-新主机选取规则" class="headerlink" title="12.7.4 新主机选取规则"></a>12.7.4 新主机选取规则</h4><p>（1）选择优先级靠前的</p>
<p>​    优先级在redis.conf中可以设置，默认为replica-priority 100，值越小优先级越大</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015144844129.png" alt="image-20211015144844129"></p>
<p>（2）选择偏移量最大的</p>
<p>​    偏移量是指获得原主机的数据最全的</p>
<p>（3）选择runid最小的从服务器</p>
<p>​    每个redis实例启动会随机生成40位的runid</p>
<h2 id="十三、Redis集群"><a href="#十三、Redis集群" class="headerlink" title="十三、Redis集群"></a>十三、Redis集群</h2><h3 id="13-1-概念"><a href="#13-1-概念" class="headerlink" title="13.1 概念"></a>13.1 概念</h3><p>​    Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中,每个节点存储总数据的1N。Redis集群通过分区( partition )来提供一定程度的可用性 ( availability ) :即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p>
<h3 id="13-2-Redis集群搭建"><a href="#13-2-Redis集群搭建" class="headerlink" title="13.2 Redis集群搭建"></a>13.2 Redis集群搭建</h3><p>（1）清空rdb等持久化文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015154146210.png" alt="image-20211015154146210"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015154212701.png" alt="image-20211015154212701"></p>
<p>（2）创建redis6379.conf、redis6380.conf、redis6381.conf、redis6389.conf、redis6390.conf、redis6391.conf六个配置文件，并进行配置修改</p>
<p>​    以6379为例，在基础配置上再添加几个集群配置</p>
<p>cluster-enabled yes 打开集群模式</p>
<p>cluster-config-file nodes-6379.conf 设定节点配置文件名</p>
<p>cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015160254798.png" alt="image-20211015160254798"></p>
<p>同理，配置其他五个文件，只不过把6379改为对应的id</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015160323002.png" alt="image-20211015160323002"></p>
<p>（3）启动6个redis服务</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015160525697.png" alt="image-20211015160525697"></p>
<p>检查开启状态</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015160628418.png" alt="image-20211015160628418"></p>
<p>查看nodes-xxxx.conf文件正确生成</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015160835491.png" alt="image-20211015160835491"></p>
<p>（4）将6个节点合成一个集群</p>
<p>首先进入redis安装目录中的src目录下，此处我的redis安装在/opt下</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015161028810.png" alt="image-20211015161028810"></p>
<p>使用redis-cli –cluster create –cluster-replicas 1 192.168.33.11:6379 192.168.33.11:6380 192.168.33.11:6381 192.168.33.11:6389 192.168.33.11:6390 192.168.33.11:6391</p>
<p>–replicas 1表示采用最简单的方式配置集群，一台主机，一台从机，正好三组</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015161639220.png" alt="image-20211015161639220"></p>
<p>之后会询问是否接受这种分配方式，yes即可</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015162405747.png" alt="image-20211015162405747"></p>
<p>如果出现一些问题，可以使用redis-cli –cluster fix 192.168.33.11:6379 这个命令来修复出问题的节点</p>
<p>redis-cli –cluster check 192.168.33.11:6379可以检查节点出现了什么问题</p>
<p>（5）连接集群</p>
<p>通过redis-cli -c -p 6379连接，-c表示采用集群策略连接，设置数据会自动切换到相应的主机，因为redis集群采用无中心连接方式，所以用任何一个节点进行连接都可以，即命令中的6379可以换成其他的端口号，如6380</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015162800239.png" alt="image-20211015162800239"></p>
<p>（6）查看节点信息</p>
<p>通过 cluster nodes可以查看集群内节点信息</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015163854551.png" alt="image-20211015163854551"></p>
<h3 id="13-3-什么是slots"><a href="#13-3-什么是slots" class="headerlink" title="13.3 什么是slots"></a>13.3 什么是slots</h3><p>​    一个Redis集群包含16384 个插槽（hash slot），数据库中的每个键都属于这16384个插槽的其中一个。<br>​    集群使用公式CRC16(key) % 16384来计算键key属于哪个槽，其中CRC16(key)语句用于计算键key的CRC16校验和。集群中的每个节点负责处理一部分插槽</p>
<p>​    向集群内插入k1 v1，经过计算，数据应该插入在12706这个插槽中，但是6379这个节点维护的是0-5460的插槽，12706并不在这个范围内，查找到在6381维护的范围内，所以直接插入到6381维护的插槽中，此时自动切换到6381节点</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015165649753.png" alt="image-20211015165649753"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015165909574.png" alt="image-20211015165909574"></p>
<p>可以使用cluster keyslot [key]来计算该key在哪个插槽</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015170337828.png" alt="image-20211015170337828"></p>
<p>使用cluster countkeysinslot [slot]可以查看该插槽内键的数量</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015170534686.png" alt="image-20211015170534686"></p>
<p>cluster getkeysinslot [slot] [count] 返回count个slot插槽中的键</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015170650837.png" alt="image-20211015170650837"></p>
<h3 id="13-4-故障恢复"><a href="#13-4-故障恢复" class="headerlink" title="13.4 故障恢复"></a>13.4 故障恢复</h3><p>​    如果主机宕机，从机会代替原主机成为主机，如果原主机再次连接，会成为从机。</p>
<p>​    如果某一段插槽的主从都宕机，而配置文件中cluster-require-full-coverage配置为yes，那么整个集群都挂掉，而如果是no，那么该插槽数据全部不能使用，也不能存储</p>
<h2 id="十四、Redis应用问题"><a href="#十四、Redis应用问题" class="headerlink" title="十四、Redis应用问题"></a>十四、Redis应用问题</h2><h3 id="14-1-缓存穿透"><a href="#14-1-缓存穿透" class="headerlink" title="14.1 缓存穿透"></a>14.1 缓存穿透</h3><h4 id="14-1-1-原因"><a href="#14-1-1-原因" class="headerlink" title="14.1.1 原因"></a>14.1.1 原因</h4><p>​    由于在缓存中并没有请求的数据，因此每次针对该key的请求都无法从缓存中获取到，只能去数据库中进行请求，从而使得压力变大崩溃</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015174245526.png" alt="image-20211015174245526"></p>
<h4 id="14-1-2-解决方案"><a href="#14-1-2-解决方案" class="headerlink" title="14.1.2 解决方案"></a>14.1.2 解决方案</h4><p>（1）对空值缓存：</p>
<p>​    如果查询返回的数据为空，我们仍然将这个空结果进行缓存，设置空结果的过期时间很短，防止存储压力过大</p>
<p>（2）设置可访问名单（白名单）：</p>
<p>​    使用bitmaps类型定义一个可以访问的白名单，名单id作为bitmaps的偏移量，如果访问id不在bitmaps里，则不允许访问</p>
<p>（3）采用布隆过滤器：</p>
<p>​        布隆过滤器可以检索一个元素是否在一个集合中，优点是空间效率和查询时间都远远超过一般算法，缺点是有一定的误判率和删除困难，可以使用布隆过滤器提高白名单的查询效率</p>
<p>（4）进行实时监控：</p>
<p>​    当发现Redis命中率开始急速降低时，排查访问对象和访问的数据，配合运维人员设置黑名单限制服务</p>
<h3 id="14-2-缓存击穿"><a href="#14-2-缓存击穿" class="headerlink" title="14.2 缓存击穿"></a>14.2 缓存击穿</h3><h4 id="14-2-1-原因"><a href="#14-2-1-原因" class="headerlink" title="14.2.1 原因"></a>14.2.1 原因</h4><p>​    redis中某个key过期了，与此同时大量的访问使用了这个key，造成数据库访问压力瞬间增大，导致缓存击穿。其与缓存穿透的不同点就是击穿发生时redis是正常运行的，也并没有出现大量Key过期的情况</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015180158775.png" alt="image-20211015180158775"></p>
<h4 id="14-2-2-解决方案"><a href="#14-2-2-解决方案" class="headerlink" title="14.2.2 解决方案"></a>14.2.2 解决方案</h4><p>（1）预先设置热门数据：在redis访问高峰之前，把一些热门数据提前存入到redis里面，并且过期时间设置的稍长</p>
<p>（2）实时调整：运维人员实时监控哪些数据热门，实时调整key的过期时长</p>
<p>（3）使用锁：当缓存失效时（即查询结果为空），不立刻去数据库查询数据，而是去设置一个查询的排他锁，如果加锁失败，说明已经有其他的线程开始查询数据库并同步缓存了，此时等待一会再重复刚才的查询操作。如果加锁成功，则前往数据库查询数据、同步缓存，成功后删除排他锁。该方案一定可以解决缓存击穿问题，但是效率较低</p>
<h3 id="14-3-缓存雪崩"><a href="#14-3-缓存雪崩" class="headerlink" title="14.3 缓存雪崩"></a>14.3 缓存雪崩</h3><h4 id="14-3-1-原因"><a href="#14-3-1-原因" class="headerlink" title="14.3.1 原因"></a>14.3.1 原因</h4><p>在极少的时间段，大量的key集中过期，访问请求无法读取数据，所以数据库访问大量增加，导致服务器崩溃</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015181924091.png" alt="image-20211015181924091"></p>
<h4 id="14-3-2-解决方案"><a href="#14-3-2-解决方案" class="headerlink" title="14.3.2 解决方案"></a>14.3.2 解决方案</h4><p>（1）构建多级缓存架构：</p>
<p>​    nginx缓存+redis缓存+其他缓存（ehcache等）</p>
<p>（2）使用锁或队列：</p>
<p>​    用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落在底层存储系统上。这种方式不适合高并发情况</p>
<p>（3）设置过期标志更新缓存：</p>
<p>​    记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的现成在后台去更新实际key的缓存</p>
<p>（4）将缓存失效时间分散开：</p>
<p>​    可以在原有的失效时间上增加一个随机值，这样过期时间重复率就会降低，降低引发集体失效的概率</p>
<h3 id="14-4总结："><a href="#14-4总结：" class="headerlink" title="14.4总结："></a>14.4总结：</h3><p>穿透是大量的无效访问，缓存中不存在这些数据，导致redis命中率降低，服务器压力增大</p>
<p>缓存击穿是高频key过期，导致大量访问直接查询数据库，导致压力增大</p>
<p>缓存雪崩是指大量的key集中过期，导致的大量访问请求落在数据库上，导致服务器崩溃</p>
<h3 id="14-4-分布式锁"><a href="#14-4-分布式锁" class="headerlink" title="14.4 分布式锁"></a>14.4 分布式锁</h3><p>​    由于分布式系统多线程、多进程并且分布在不同机器上，使得原单机部署情况下的并发控制锁策略失效，淡出的JAVA API并不能提供分布式锁的能力。为了解决这个问题，就要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题</p>
<h4 id="14-4-1-分布式锁主流方案："><a href="#14-4-1-分布式锁主流方案：" class="headerlink" title="14.4.1 分布式锁主流方案："></a>14.4.1 分布式锁主流方案：</h4><p>（1）基于数据库实现分布式锁</p>
<p>（2）基于缓存（Redis等）</p>
<p>（3）基于Zookeeper</p>
<p>每一种锁都有各自的优缺点：</p>
<p>（1）性能：redis最高</p>
<p>（2）可靠性：zookeeper最高</p>
<h4 id="14-4-2-使用redis实现分布式锁"><a href="#14-4-2-使用redis实现分布式锁" class="headerlink" title="14.4.2 使用redis实现分布式锁"></a>14.4.2 使用redis实现分布式锁</h4><p>set [key] [value] nx ex [time] </p>
<p>del [key] 可以释放锁</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211015204825479.png" alt="image-20211015204825479"></p>
<h4 id="14-4-3-UUID防止误删"><a href="#14-4-3-UUID防止误删" class="headerlink" title="14.4.3 UUID防止误删"></a>14.4.3 UUID防止误删</h4><p>​    在上锁时，通过uuid表示不同的操作</p>
<p>​    set lock uuid nx ex 10</p>
<p>​    在释放锁时，首先判断uuid和要释放锁的uuid是否一样，如果一样正常释放，如果不一样无法释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">String lockUuid  = (string)redisTemplate.opsForValue().get(<span class="string">"lock"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lockUuid.equals(uuid))&#123;</span><br><span class="line">  redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这种方式下，由于没有原子性，导致会出现一定的问题，如在a想要释放锁的时候，首先比较了uuid发现可以删除，但是还没有删除的时候，自动释放时间到了，导致锁自动释放，这时b获得锁，进行具体操作，此时a进行了释放操作，导致b得到的锁被释放</p>
<p>​    可以使用lua脚本来实现</p>
]]></content>
      <categories>
        <category>【数据库】</category>
      </categories>
      <tags>
        <tag>【Redis】</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2接口文档基础使用方法</title>
    <url>/2021/10/02/Swagger2%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Swagger接口文档是前后端分离时常用的工具，从接口文档上可以直接发送请求测试接口，其有如下优势：</p>
<p>1.Api文档与API定义同步更新</p>
<p>2.直接运行，可以在线测试API接口</p>
<p>3.支持多种语言</p>
<p>官网 ： <a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p>
<h2 id="二、Swagger2配置"><a href="#二、Swagger2配置" class="headerlink" title="二、Swagger2配置"></a>二、Swagger2配置</h2><h3 id="2-1-需要引入的依赖"><a href="#2-1-需要引入的依赖" class="headerlink" title="2.1 需要引入的依赖"></a>2.1 需要引入的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--swagger2 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- swagger2 ui依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然还可以引入其他作者编写的第三方UI界面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Swagger第三方UI依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-配置类注解"><a href="#2-2-配置类注解" class="headerlink" title="2.2 配置类注解"></a>2.2 配置类注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Config</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-配置Docket实例"><a href="#2-3-配置Docket实例" class="headerlink" title="2.3 配置Docket实例"></a>2.3 配置Docket实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket  <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4配置swagger-apiInfo"><a href="#2-4配置swagger-apiInfo" class="headerlink" title="2.4配置swagger apiInfo"></a>2.4配置swagger apiInfo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">"云E办接口文档"</span>)</span><br><span class="line">      			.description(<span class="string">"接口文档"</span>)</span><br><span class="line">            .contact(<span class="keyword">new</span> Contact(<span class="string">"sdh"</span>,</span><br><span class="line">                                 <span class="string">"https://xxxxxxx.github.io/"</span>,</span><br><span class="line">                                 <span class="string">"123456789@qq.com"</span>))</span><br><span class="line">            .version(<span class="string">"1.0"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中title是文档名称</p>
<p>description是文档描述</p>
<p>contact是作者信息</p>
<p>version是版本</p>
<h3 id="2-5-Swagger配置扫描接口"><a href="#2-5-Swagger配置扫描接口" class="headerlink" title="2.5 Swagger配置扫描接口"></a>2.5 Swagger配置扫描接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket  <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">          	.apis(RequestHandlerSelectors.</span><br><span class="line">         		 			basePackage(<span class="string">"com.xxx.server.controller"</span>))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中apiInfo()传入我们刚刚写好的apiInfo,之后再.select开始配置扫描接口，此处采用了建造者模式，在.selcet后只有.apis、.paths、.build三个选项。</p>
<h4 id="1-apis"><a href="#1-apis" class="headerlink" title="(1) .apis"></a>(1) .apis</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage())</span><br></pre></td></tr></table></figure>

<p>basePackage()表示基于包扫描，例如下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(<span class="string">"com.sundaohan.server.controller"</span>))</span><br></pre></td></tr></table></figure>

<p>any()表示搜索全部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.any())</span><br></pre></td></tr></table></figure>

<p>none()表示都不扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.none())</span><br></pre></td></tr></table></figure>

<p>withClassAnnatation()表示按类上的注解扫描，需要传入一个注解的反射对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation())</span><br></pre></td></tr></table></figure>

<p>例如想扫描RestController注解修饰的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation(RestController<span class="class">.<span class="keyword">class</span>))</span></span><br></pre></td></tr></table></figure>

<p>withMethodAnnotation()表示按方法上的注解扫描，需要传入一个注解的反射对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation())</span><br></pre></td></tr></table></figure>

<p>例如想扫描GetMapping修饰的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping<span class="class">.<span class="keyword">class</span>))</span></span><br></pre></td></tr></table></figure>

<h4 id="2-paths"><a href="#2-paths" class="headerlink" title="(2) .paths"></a>(2) .paths</h4><p>.paths()用来过滤路径，表示扫描什么路径下的内容</p>
<p>.any()表示扫描全部路径下的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.paths(PathSelectors.any())</span><br></pre></td></tr></table></figure>

<p>.none()表示全都不扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.paths(PathSelectors.none())</span><br></pre></td></tr></table></figure>

<p>.ant()表示扫描带有指定路径的接口，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.paths(PathSelectors.ant(<span class="string">"/api/**"</span>))</span><br></pre></td></tr></table></figure>

<p>表示只扫描请求以/api开头的接口，其他的不会扫描</p>
<h4 id="3-enable"><a href="#3-enable" class="headerlink" title="(3).enable()"></a>(3).enable()</h4><p>控制swagger是否开启，需要传入一个布尔值作为参数，默认为true，即开启状态</p>
<p>如果想要关闭，传入false即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.enable(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<p>设置完成后，访问localhost:端口号/doc.html就可以看到接口文档界面了</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20211002210147820.png" alt="image-20211002210147820"></p>
]]></content>
      <categories>
        <category>【语言学习】</category>
      </categories>
      <tags>
        <tag>【工具】</tag>
      </tags>
  </entry>
  <entry>
    <title>【go】跨平台编译</title>
    <url>/2021/09/30/%E3%80%90go%E3%80%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h1><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin//Mac</span><br><span class="line">SET GOARCH=amd64</span><br></pre></td></tr></table></figure>



<h3 id="2-MAC"><a href="#2-MAC" class="headerlink" title="2.MAC"></a>2.MAC</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build//Linux</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build//Windows</span><br></pre></td></tr></table></figure>



<h3 id="3-Linux"><a href="#3-Linux" class="headerlink" title="3.Linux"></a>3.Linux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>【语言学习】</category>
      </categories>
      <tags>
        <tag>【golang】</tag>
      </tags>
  </entry>
  <entry>
    <title>经典共识PoW的原理及实现</title>
    <url>/2021/09/30/%E7%BB%8F%E5%85%B8%E5%85%B1%E8%AF%86PoW%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="经典共识PoW的原理及实现"><a href="#经典共识PoW的原理及实现" class="headerlink" title="经典共识PoW的原理及实现"></a>经典共识PoW的原理及实现</h1><h2 id="一、PoW简介"><a href="#一、PoW简介" class="headerlink" title="一、PoW简介"></a>一、PoW简介</h2><p>​    PoW(Proof of Work)是工作量证明的简称，最早使用在防止拒绝服务攻击以及过滤垃圾邮件，现在成为区块链公链中最常见也是最有效的共识算法之一，当下最流行的比特币、以太坊等公链目前均使用PoW共识。</p>
<p>​    PoW是通过对一个复杂难题的求解，来保证区块链交易打包出块的公平性，即最先解决难题的矿工，可以获得记账权，并将打包好的区块发送至其他节点验证上链，从而获得激励。在保证能够在不可信的环境下创造可信的同时，运用PoW还可以天然的防御女巫攻击等针对区块链的攻击。</p>
<p>​    由于PoW要求所有矿工节点都解决无意义的复杂难题，导致了巨大的资源浪费，因此，最新的以太坊版本考虑使用PoS代替PoW成为其共识算法。</p>
<h2 id="二、PoW原理及实现"><a href="#二、PoW原理及实现" class="headerlink" title="二、PoW原理及实现"></a>二、PoW原理及实现</h2><p>​    在介绍PoW原理之前，需要先了解一些知识。</p>
<h3 id="2-1-区块头"><a href="#2-1-区块头" class="headerlink" title="2.1 区块头"></a>2.1 区块头</h3><p>​    在区块链中，区块分为区块头和区块体两部分，区块体以默克尔树的数据结构存储了交易数据，区块头存储了上一个区块的Hash、默克尔树树根值、时间戳、难度值、区块高度等等非交易数据信息。</p>
<h3 id="2-2-哈希计算"><a href="#2-2-哈希计算" class="headerlink" title="2.2 哈希计算"></a>2.2 哈希计算</h3><p>​    哈希计算实际上就是使用哈希函数(散列函数)对不同长度的数据都能计算出等长的输出，而且对数据微小差距都十分敏感，比如”hello world”和”Hello world”的哈希值差距都是巨大的。</p>
<h3 id="2-3-原理及实现"><a href="#2-3-原理及实现" class="headerlink" title="2.3 原理及实现"></a>2.3 原理及实现</h3><p>​    PoW的原理十分简单，实际上就是计算一个随机数Nounce，要求这个Nounce和区块头拼接后做的哈希值小于我们预设的值。具体实现如下：</p>
<p>​    1.预设一个难度值targetBit，比如我们想PoW计算出的Hash值最前面开始有16个0，则设置该值为16。</p>
<p>​    2.找到判断是否找出正确Nounce值的临界值target，在比特币中，PoW使用的是SHA256，输出的哈希值都是256位的，比如设置的难度值是16，那么我们最终应该得到的值的形式应该是 0000 0000 0000 0000 xxxx……xxxx(共256位)，那么我们可以得知，当我得到的值小于0000 0000 0000 0001 0000……0000(共256位)时，该值合法，因为这个值已经小于了前面有15个0的最小值，那么其前面一定有16个0。</p>
<p>​    所以我们只要将临界值target先设置为1,二进制表示为0000 0000……0001(共256位)，再将这个值左移256-targetBit = 256 - 16 = 240位，即可得到前面有15个0的最小值，即0000 0000 0000 0001 0000……0000(共256位)。</p>
<p>​    3.将随机数Nounce置为0，再拼接上区块头的内容，计算其哈希值，如果大于了我们的目标值target，则将Nounce加1，再拼接区块头的内容计算哈希。重复上述过程，直到计算出小于target的哈希值，此时的Nounce就是最终的解。</p>
<p>​    </p>
<h2 id="三、PoW的go语言实现"><a href="#三、PoW的go语言实现" class="headerlink" title="三、PoW的go语言实现"></a>三、PoW的go语言实现</h2><p>1.首先定义工作量证明对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">   Block  *Block   <span class="comment">//当前要验证的区块</span></span><br><span class="line">   target *big.Int <span class="comment">//大数存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.定义难度值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//256位hash里面至少有16个零</span></span><br><span class="line"><span class="keyword">const</span> targetBit = <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>3.初始化工作量证明对象，计算出临界值target</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span> *<span class="title">ProofOfWork</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个初始值为1的target</span></span><br><span class="line">   target := big.NewInt(<span class="number">1</span>)</span><br><span class="line">   <span class="comment">//左移256-targetBit</span></span><br><span class="line">   target = target.Lsh(target, <span class="number">256</span>-targetBit)</span><br><span class="line">   <span class="keyword">return</span> &amp;ProofOfWork&#123;</span><br><span class="line">      block,</span><br><span class="line">      target,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.拼接Nounce值和区块头中的内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   join := bytes.Join(</span><br><span class="line">      [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">         proofOfWork.Block.PreBlockHash,<span class="comment">//前一个区块的hash</span></span><br><span class="line">         proofOfWork.Block.HashTransactions(),<span class="comment">//默克尔树根</span></span><br><span class="line">         Utils.IntToHex(proofOfWork.Block.TimeStamp),<span class="comment">//时间戳</span></span><br><span class="line">         Utils.IntToHex(<span class="keyword">int64</span>(targetBit)),<span class="comment">//难度值</span></span><br><span class="line">         Utils.IntToHex(<span class="keyword">int64</span>(nonce)),<span class="comment">//Nounce</span></span><br><span class="line">         Utils.IntToHex(<span class="keyword">int64</span>(proofOfWork.Block.Height)),<span class="comment">//区块高度</span></span><br><span class="line">      &#125;,</span><br><span class="line">      []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">return</span> join</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.开始进行工作量证明计算</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   nonce := <span class="number">0</span></span><br><span class="line">   <span class="keyword">var</span> hashInt big.Int <span class="comment">//存储我们新生成的hash</span></span><br><span class="line">   <span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 将BLOCK属性拼接成字节数组</span></span><br><span class="line">      dataBytes := proofOfWork.prepareData(nonce)</span><br><span class="line">      <span class="comment">// 生成hash, sum256返回32位需要转换为64位</span></span><br><span class="line">      hash = sha256.Sum256(dataBytes)</span><br><span class="line">      <span class="comment">// 将hash存储到hashInt,采取hash[:]将切片转换为64位</span></span><br><span class="line">      hashInt.SetBytes(hash[:])</span><br><span class="line">      fmt.Printf(<span class="string">"\r%x"</span>, hash)</span><br><span class="line">      <span class="comment">// 判断hashInt是否小于Block里面的target</span></span><br><span class="line">      <span class="comment">// x &lt; y -1</span></span><br><span class="line">      <span class="comment">// x == y 0</span></span><br><span class="line">      <span class="comment">// x &gt; y 1</span></span><br><span class="line">      <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">         <span class="comment">//判断有效性，如果满足条件，跳出循环</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      nonce = nonce + <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> hash[:], <span class="keyword">int64</span>(nonce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.编写当需要验证Nounce值是否合法时的验证函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> hashInt big.Int</span><br><span class="line">	hashInt.SetBytes(proofOfWork.Block.Hash)</span><br><span class="line">  <span class="comment">//判断提供的hash是否小于target</span></span><br><span class="line">	<span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>【实践】</category>
      </categories>
      <tags>
        <tag>【共识机制】</tag>
      </tags>
  </entry>
  <entry>
    <title>【go】基本数据类型</title>
    <url>/2021/07/10/%E3%80%90go%E3%80%91%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="一、整型"><a href="#一、整型" class="headerlink" title="一、整型"></a>一、整型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h3 id="1-特殊整型"><a href="#1-特殊整型" class="headerlink" title="1.特殊整型"></a>1.特殊整型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h3 id="2-数字字面量语法"><a href="#2-数字字面量语法" class="headerlink" title="2.数字字面量语法"></a>2.数字字面量语法</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：<code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>
<p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>
<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 八进制  以0开头</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">	fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-浮点型"><a href="#3-浮点型" class="headerlink" title="3.浮点型"></a>3.浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-复数"><a href="#4-复数" class="headerlink" title="4.复数"></a>4.复数</h3><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure>

<h3 id="5-布尔"><a href="#5-布尔" class="headerlink" title="5.布尔"></a>5.布尔</h3><p><code>bool</code>表示<code>true</code>或者<code>false</code>,默认为<code>false</code>,布尔型不能进行数值运算，也不能和其他类型转换，</p>
<h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h3><p>字符串双引号包裹</p>
<p>字符单引号包裹</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">"sdh"</span></span><br><span class="line">s2 := <span class="string">"孙道涵"</span></span><br><span class="line"><span class="comment">//1个字符’A‘ = 8Bit(8个二进制位)</span></span><br><span class="line"><span class="comment">//1个字符'A' = 1字节</span></span><br><span class="line"><span class="comment">//1个utf-8的汉字一般3个字节</span></span><br><span class="line">c1 := <span class="string">'s'</span></span><br></pre></td></tr></table></figure>

<h3 id="7-字符串转义符"><a href="#7-字符串转义符" class="headerlink" title="7.字符串转义符"></a>7.字符串转义符</h3><table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<h3 id="8-多行字符串"><a href="#8-多行字符串" class="headerlink" title="8.多行字符串"></a>8.多行字符串</h3><p>使用反引号定义多行字符串，反引号包裹中的换行会作为字符串中的换行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`</span></span><br><span class="line"><span class="string">	知行合一</span></span><br><span class="line"><span class="string">	自强不息</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>

<h3 id="9-字符串常用操作"><a href="#9-字符串常用操作" class="headerlink" title="9.字符串常用操作"></a>9.字符串常用操作</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>
<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>
<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>
<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>
<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>
<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>
<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody></table>
<p>TODO</p>
<h3 id="10-字符类型"><a href="#10-字符类型" class="headerlink" title="10.字符类型"></a>10.字符类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'中'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'x'</span></span><br></pre></td></tr></table></figure>

<h4 id="1-byte类型"><a href="#1-byte类型" class="headerlink" title="1.byte类型"></a>1.byte类型</h4><p>uint8<code>类型，或者叫 byte 型，代表了</code>ASCII码的一个字符。</p>
<h4 id="2-rune类型"><a href="#2-rune类型" class="headerlink" title="2.rune类型"></a>2.rune类型</h4><p><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。处理中文可以使用该类型，<code>rune</code>实际上是<code>int32</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c1 := <span class="string">'你'</span></span><br><span class="line">fmt.Printf(<span class="string">"c1 : %T\n"</span>, c1)<span class="comment">//int32</span></span><br></pre></td></tr></table></figure>

<h4 id="3-字符串更改"><a href="#3-字符串更改" class="headerlink" title="3.字符串更改"></a>3.字符串更改</h4><p>字符串是不能修改的，如果要修改，只能转换之后修改再赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">"早上好"</span></span><br><span class="line">s2 := []<span class="keyword">rune</span>(s1)<span class="comment">//字符串s1强制转换为rune切片</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="string">'晚'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(s2))<span class="comment">//晚上好</span></span><br></pre></td></tr></table></figure>

<h3 id="11-类型转换"><a href="#11-类型转换" class="headerlink" title="11.类型转换"></a>11.类型转换</h3><p>Go中只有强制类型转换，没有隐式类型转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">10</span><span class="comment">//int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">f = <span class="keyword">float64</span>(n)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>【语言学习】</category>
      </categories>
      <tags>
        <tag>【golang】</tag>
      </tags>
  </entry>
  <entry>
    <title>【go】fmt占位符</title>
    <url>/2021/07/10/%E3%80%90go%E3%80%91fmt%E5%8D%A0%E4%BD%8D%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="fmt占位符"><a href="#fmt占位符" class="headerlink" title="fmt占位符"></a>fmt占位符</h1><p>格式化输出使用<code>fmt.Printf()</code>时，可以使用如<code>%s</code>的占位符</p>
<p>占位符类型如下：</p>
<h2 id="1-查看类型"><a href="#1-查看类型" class="headerlink" title="1.查看类型"></a>1.查看类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, n)</span><br></pre></td></tr></table></figure>

<h3 id="2-查看变量值"><a href="#2-查看变量值" class="headerlink" title="2.查看变量值"></a>2.查看变量值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, n)</span><br></pre></td></tr></table></figure>

<h3 id="3-查看二进制"><a href="#3-查看二进制" class="headerlink" title="3.查看二进制"></a>3.查看二进制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%b\n"</span>, n)</span><br></pre></td></tr></table></figure>

<h3 id="4-查看八进制"><a href="#4-查看八进制" class="headerlink" title="4.查看八进制"></a>4.查看八进制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%o\n"</span>, n)</span><br></pre></td></tr></table></figure>

<h3 id="5-查看十进制"><a href="#5-查看十进制" class="headerlink" title="5.查看十进制"></a>5.查看十进制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, n)</span><br></pre></td></tr></table></figure>

<h3 id="6-查看十六进制"><a href="#6-查看十六进制" class="headerlink" title="6.查看十六进制"></a>6.查看十六进制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, n)</span><br></pre></td></tr></table></figure>

<h3 id="7-查看字符串"><a href="#7-查看字符串" class="headerlink" title="7.查看字符串"></a>7.查看字符串</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, n)</span><br></pre></td></tr></table></figure>

<p>TODO</p>
]]></content>
      <categories>
        <category>【语言学习】</category>
      </categories>
      <tags>
        <tag>【golang】</tag>
      </tags>
  </entry>
  <entry>
    <title>【go】变量与常量</title>
    <url>/2021/07/09/%E3%80%90go%E3%80%91%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="一-变量"><a href="#一-变量" class="headerlink" title="一.变量"></a>一.变量</h2><h3 id="1-声明声明"><a href="#1-声明声明" class="headerlink" title="1.声明声明"></a>1.声明声明</h3><p>声明格式：var 变量名 变量类型</p>
<p>不需要写分号;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span> <span class="comment">//声明字符串变量s1；</span></span><br><span class="line"><span class="keyword">var</span> s2 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> s3 <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> s4 <span class="keyword">string</span> = <span class="string">"sdh"</span><span class="comment">//声明同时赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="2-批量声明"><a href="#2-批量声明" class="headerlink" title="2.批量声明"></a>2.批量声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  name <span class="keyword">string</span> <span class="comment">//""</span></span><br><span class="line">  age <span class="keyword">int</span> <span class="comment">// 0</span></span><br><span class="line">  isOk <span class="keyword">bool</span> <span class="comment">// false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-类型推导"><a href="#3-类型推导" class="headerlink" title="3.类型推导"></a>3.类型推导</h3><p>根据赋值自动判断什么类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"sdh"</span><span class="comment">//根据"sdh"自动判断string类型</span></span><br></pre></td></tr></table></figure>

<h3 id="4-简短变量声明"><a href="#4-简短变量声明" class="headerlink" title="4.简短变量声明"></a>4.简短变量声明</h3><p>只能在函数里使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">"sdh"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-匿名变量"><a href="#5-匿名变量" class="headerlink" title="5.匿名变量"></a>5.匿名变量</h3><p>​    使用多重赋值的时候，某个值不需要使用，可以用<code>_</code>忽略该变量值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>,<span class="string">"abc"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  x, _ := a()</span><br><span class="line">  _, y := a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-三种打印方法"><a href="#6-三种打印方法" class="headerlink" title="6.三种打印方法"></a>6.三种打印方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Print(name)<span class="comment">//打印</span></span><br><span class="line">fmt.Printf(<span class="string">"name = %s\n"</span>, name)<span class="comment">//格式化输出，%s占位符</span></span><br><span class="line">fmt.<span class="built_in">println</span>(name)<span class="comment">//打印完自动换行</span></span><br></pre></td></tr></table></figure>

<h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7.注意事项"></a>7.注意事项</h3><p>定义的变量必须使用，否则报错；全局变量不使用也不会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//全局变量，不使用也没报错</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//未使用 报错</span></span><br><span class="line">	<span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">string</span> = <span class="string">"sdh"</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、常量"><a href="#二、常量" class="headerlink" title="二、常量"></a>二、常量</h2><h3 id="1-声明常量"><a href="#1-声明常量" class="headerlink" title="1.声明常量"></a>1.声明常量</h3><p>常量定义之后不可更改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br></pre></td></tr></table></figure>

<h3 id="2-批量声明常量"><a href="#2-批量声明常量" class="headerlink" title="2.批量声明常量"></a>2.批量声明常量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  n1 = <span class="number">100</span></span><br><span class="line">  n2 = <span class="number">200</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果批量声明常量时，如果某一行声明没有赋值，默认同上</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  n1 = <span class="number">100</span></span><br><span class="line">  n2 <span class="comment">//默认和n1一样</span></span><br><span class="line">  n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-iota"><a href="#3-iota" class="headerlink" title="3.iota"></a>3.iota</h3><p>iota是计数器，只能在常量表达式中使用</p>
<p>iota在const关键字出现时会被重置为0，const中每新增一行常量声明会使iota计数一次。在定义枚举的时候很有用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a1 = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">  a2 <span class="comment">//1</span></span><br><span class="line">  a3 <span class="comment">//2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  b1 = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">  b2 <span class="comment">//1</span></span><br><span class="line">  _</span><br><span class="line">  b3 <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a1 = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">  a2 = <span class="number">100</span></span><br><span class="line">  a3 = <span class="string">"abc"</span></span><br><span class="line">  a4 = <span class="literal">iota</span> <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意，iota新增一行变量才会+1，如果一行声明多个变量，也只会+1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  d1, d2 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span><span class="comment">// 1, 2</span></span><br><span class="line">  d3, d4 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span><span class="comment">// 2, 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>定义数量级</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  _ = <span class="literal">iota</span><span class="comment">//丢弃无意义0</span></span><br><span class="line">  KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//1024</span></span><br><span class="line">  MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">  GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">  TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">  PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>【语言学习】</category>
      </categories>
      <tags>
        <tag>【golang】</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS系统下运行本地以太坊源码</title>
    <url>/2021/07/09/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h1><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin//Mac</span><br><span class="line">SET GOARCH=amd64</span><br></pre></td></tr></table></figure>



<h3 id="2-MAC"><a href="#2-MAC" class="headerlink" title="2.MAC"></a>2.MAC</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build//Linux</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build//Windows</span><br></pre></td></tr></table></figure>



<h3 id="3-Linux"><a href="#3-Linux" class="headerlink" title="3.Linux"></a>3.Linux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>【语言学习】</category>
      </categories>
      <tags>
        <tag>【golang】</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PoA共识机制的以太坊私链在阿里云服务器上的搭建和连接</title>
    <url>/2020/12/24/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%9F%BA%E4%BA%8EPoA%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE%E6%90%AD%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><ul>
<li>操作系统：MacOS 10.15以上版本(win一样)</li>
<li>阿里云服务器(ubuntu 16.04)</li>
</ul>
<h1 id="二、准备环节——阿里云服务器相关操作"><a href="#二、准备环节——阿里云服务器相关操作" class="headerlink" title="二、准备环节——阿里云服务器相关操作"></a>二、准备环节——阿里云服务器相关操作</h1><p>1.购买云服务器(略过)</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211007792.png" alt="image-20201224211007792"></p>
<p>2.更改云服务器连接密码，点击右上角的三个小点，然后点击重置实例密码</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211134465.png" alt="image-20201224211134465"></p>
<p>输入并牢记密码，通过终端远程登录时需要用到</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211235459.png" alt="image-20201224211235459"></p>
<p>3.点击配置安全组配置安全组规则，点击右侧的配置规则</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211427406.png" alt="image-20201224211427406"></p>
<p>点击快速添加，点击SSH(22)，方便后续终端远程连接服务器</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211538351.png" alt="image-20201224211538351"></p>
<p>4.打开终端，输入ssh <a href="mailto:root@xxx.xxx.xxx.xxx">root@xxx.xxx.xxx.xxx</a>(服务器的公网IP)</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211659759.png" alt="image-20201224211659759"></p>
<p>按要求输入密码，成功连接并控制云服务器</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224211747538.png" alt="image-20201224211747538"></p>
<h1 id="三、ubuntu中下载以太坊源码"><a href="#三、ubuntu中下载以太坊源码" class="headerlink" title="三、ubuntu中下载以太坊源码"></a>三、ubuntu中下载以太坊源码</h1><p>1.更新软件包信息</p>
<p>apt-get upadate</p>
<p>2.添加ppa到当前库中并且自动导入公钥</p>
<p>apt-get install software-properties-common </p>
<p>add-apt-repository -y ppa:ethereum/ethereum</p>
<p>add-apt-repository -y ppa:ethereum/ethereum-dev </p>
<p>apt-get update</p>
<p>3.安装以太坊</p>
<p>apt-get install ethereum</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224212018402.png" alt="image-20201224212018402"></p>
<p>4.查看版本号确认安装成功</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224212132131.png" alt="image-20201224212132131"></p>
<h1 id="四、以太坊账户创建"><a href="#四、以太坊账户创建" class="headerlink" title="四、以太坊账户创建"></a>四、以太坊账户创建</h1><p>​    搭建以太坊私链之前要先创建相应的账户，可以创建在任意位置创建任意数量的账户，在这里举一个简单的例子，在云服务器上创建一个账户，在自己的电脑上创建三个账户。</p>
<p>1.连接云服务器，创建一个用来装节点的文件夹</p>
<p>mkdir MyEth(你喜欢的名字，什么都行)</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224212429508.png" alt="image-20201224212429508"></p>
<p>2.进入文件夹中</p>
<p>cd MyEth</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224212516579.png" alt="image-20201224212516579"></p>
<p>3.使用命令创建第一个账户，输入命令后，按要求输入两次密码，即可得到该账户的公钥地址，牢记</p>
<p>geth –datadir node1/data account new</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224212710013.png" alt="image-20201224212710013"></p>
<p>4.在自己的本地电脑上，创建一个文件夹，同样用来装节点信息，推荐和云服务器上的文件夹名字相同</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224212825930.png" alt="image-20201224212825930"></p>
<p>5.同样的方式，通过终端进入该文件夹，创建三个账户 node2,node3,node4</p>
<p>cd MyEth</p>
<p>geth –datadir node2/data account new</p>
<p>geth –datadir node3/data account new</p>
<p>geth –datadir node4/data account new</p>
<p>同样，牢记公钥地址，配置创始区块时需要</p>
<h1 id="五、配置创世区块"><a href="#五、配置创世区块" class="headerlink" title="五、配置创世区块"></a>五、配置创世区块</h1><p>以太坊的私链想要达成节点互连，有两个必要条件：</p>
<p>1.创世区块配置文件相同</p>
<p>2.有相同的ChainID</p>
<p>我们通过已有的puppeth工具创建配置区块文件</p>
<p>1.切换到云服务器中，在MyEth文件夹下，输入命令puppeth，输入该配置的名称，任意都行，此处我填写sdh</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224213552246.png" alt="image-20201224213552246"></p>
<p>填写之后，工具会检测该配置是否存在，如果不存在，第二个选项则是配置新的创世区块，否则是管理该配置，这里展示配置新创世区块的选项</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224213704416.png" alt="image-20201224213704416"></p>
<p>选择2，配置新的创世区块，之后的选项1是创建新的创世区块，2是导入一个已经存在的配置，这里选择1</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224213752479.png" alt="image-20201224213752479"></p>
<p>这里的选项是选择该链所用的共识机制，第一个是以太坊的公链共识机制PoW，显然不适合私链或者联盟链，所以这里选择2 Clique，该共识机制是基于PoA的，此处不详细解释</p>
<p>![image-20201224213843219](/Users/sundaohan/Library/Application Support/typora-user-images/image-20201224213843219.png)</p>
<p>这里是出块时间，没有特殊需求默认就行（直接回车或者打上15再回车都行）</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224214006727.png" alt="image-20201224214006727"></p>
<p>这里就比较重要了，是允许挖矿的账户，上一步我们创建了共四个账户，一个是在云服务器上的node1，和在本地的三个账户node2,node3,node4，我们可以选择一个或者多个当做挖矿节点，我这里选择了node3，填写完成以回车结束该选项</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224214314198.png" alt="image-20201224214314198"></p>
<p>这一部分是设置预置资金账号，这部分账号里可以有初始资金，这里我设置了node1和node3</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224214839557.png" alt="image-20201224214839557"></p>
<p>这一步选择是否给刚才设置的预置资金账号存点钱，yes就行</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224214930272.png" alt="image-20201224214930272"></p>
<p>这一步很重要，关系到能否互连，是设置chainID，如果两个节点想要互连，那么输入的chainID必须相同，输入一个能记住的号，最好大于5</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224214946493.png" alt="image-20201224214946493"></p>
<p>到这里创世区块配置就完成了，再出现的二号选项就变成了管理已经存在的配置，选择2进入管理界面</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224215113354.png" alt="image-20201224215113354"></p>
<p>选择2，将已经配置好的创世区块文件导出</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224215139505.png" alt="image-20201224215139505"></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224215154172.png" alt="image-20201224215154172"></p>
<p>我这里报了错误，还没弄明白是为什么，但是并不影响使用，搞定后直接ctrl+c退出puppeth</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224215537367.png" alt="image-20201224215537367"></p>
<p>然后打开自己电脑的本地终端，输入以下命令将刚才已经导出的创世区块配置文件下载到本地电脑下的MyEth文件夹中</p>
<p>scp <a href="mailto:root@8.131.78.39">root@8.131.78.39</a>:/root/MyEth/sdh.json /Users/sundaohan/MyEth</p>
<p>该命令的格式为</p>
<p>scp <a href="mailto:root@xxx.xxx.xxx.xxx">root@xxx.xxx.xxx.xxx</a>(云服务器公网IP) :/xx/xx/xx.xx（远程目录） 『空格』 /xxx/xxx/xxx(目标目录)</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224215904212.png" alt="image-20201224215904212"></p>
<p>![image-20201224215922977](/Users/sundaohan/Library/Application Support/typora-user-images/image-20201224215922977.png)</p>
<p>可以看到该文件已经下载成功了</p>
<p>至此，创世区块配置的准备工作已经全部完成</p>
<h1 id="六、初始化私有链"><a href="#六、初始化私有链" class="headerlink" title="六、初始化私有链"></a>六、初始化私有链</h1><p>回到云服务器终端上，在MyEth文件下，输入命令</p>
<p>geth –datadir node1/data init sdh.json(创世区块配置文件名称)</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224220150933.png" alt="image-20201224220150933"></p>
<p>在自己电脑的本地文件夹下，也运行同样的命令，记得把node1改成相应节点的名字</p>
<p>geth –datadir node2/data init sdh.json </p>
<p>geth –datadir node3/data init sdh.json </p>
<p>geth –datadir node4/data init sdh.json</p>
<p>全部运行成功后，四个节点的初始化就完成了</p>
<h1 id="七、启动节点"><a href="#七、启动节点" class="headerlink" title="七、启动节点"></a>七、启动节点</h1><p>​    1.首先启动云服务器的节点，先切换到云服务器的MyEth文件夹下，运行如下命令</p>
<p>geth –datadir node1/data –nodiscover –networkid 98512 –port 3000 console</p>
<p>其中</p>
<p>datadir:指定数据库和keystore密钥的数据目录</p>
<p>nodiscover(重要):禁止节点发现，只允许手动添加节点，如果不写这个我们的私链可能会被别人发现，但是写了这个选项会增强链的隐蔽性，只能手动添加</p>
<p>networkid: 网络标识符，这个在创世区块的配置时已经写定，所有想要加入这个私链中的节点都要写相同的网络标识符</p>
<p>port:网卡监听端口,每个节点都要有这个端口号，默认是30303，保证每个节点使用的都不同</p>
<p>还有很多其他选项，这里不再赘述</p>
<p>命令输入成功后，node1就启动完毕了</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224234804316.png" alt="image-20201224234804316"></p>
<p>2.切换回自己的电脑终端，开启多个终端窗口，分别启动node2、node3、node4，命令与刚才相似</p>
<p>geth –datadir node2/data –networkid 98512 –port 3001 console</p>
<p>geth –datadir node3/data –networkid 98512 –port 3002 console</p>
<p>geth –datadir node4/data –networkid 98512 –port 3003 console</p>
<p>至此，节点已经全部启动</p>
<h1 id="八、连接"><a href="#八、连接" class="headerlink" title="八、连接"></a>八、连接</h1><p>​    节点启动后，开始进行连接操作，连接使用的admin.addPeer(encode)命令，首先在四个已经启动的节点下输入如下命令查看每个节点的encode值</p>
<p>admin.nodeInfo</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224235715672.png" alt=""></p>
<p>第一行中的</p>
<p>“enode://94900340edefd9f8b1d269682bea6df2a4394966b972026d930c50356e2b90a6f2de74beccab042324a81d108ea419d9336d889c261b8f0ce932a8b01206f8ed@127.0.0.1:3000?discport=0”</p>
<p>即是节点的encode值，如果要连接的节点不在同一个网络下，比如我们启动的node1是在云服务器上，node2、node3、node4是在自己的电脑上，那么node2、node3、node4即在同一网络下，而node1与另外三个节点就不在同一节点下，此时如果想要使他们互连，就要将encode中127.0.0.1换成节点的真实的IP地址。我的云服务器公网地址是8.131.78.39，那我如果想要用node2连接node1，就要在node2的终端中输入</p>
<p>admin.addPeer(“enode://94900340edefd9f8b1d269682bea6df2a4394966b972026d930c50356e2b90a6f2de74beccab042324a81d108ea419d9336d889c261b8f0ce932a8b01206f8ed@8.131.78.39:3000?discport=0”)</p>
<p>如果输入正确，会返回true，但是并不代表已经连接上了</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224235801556.png" alt="image-20201224235801556"></p>
<p>此时切换到node1的节点终端，输入命令</p>
<p>admin.peers</p>
<p>可以看到所有已经连接上的节点，此时我们看到node2已经连接上了</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20201224235931943.png" alt="image-20201224235931943"></p>
<p>继续将剩下的节点连接，一条完整的基于PoA共识机制的私链就完成了，等到下次再开启节点时，他们会自动连接</p>
]]></content>
      <categories>
        <category>【实践】</category>
      </categories>
      <tags>
        <tag>【以太坊】</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos共识算法的GO语言模拟</title>
    <url>/2020/11/25/Paxos%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%9A%84GO%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>【实践】</category>
      </categories>
      <tags>
        <tag>【共识机制】</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊中Ghost协议与叔块</title>
    <url>/2020/10/11/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%ADGhost%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8F%94%E5%9D%97/</url>
    <content><![CDATA[<h2 id="Ghost协议为什么出现"><a href="#Ghost协议为什么出现" class="headerlink" title="Ghost协议为什么出现"></a>Ghost协议为什么出现</h2><p>​    与比特币相比，以太坊大大缩减了其出块的时间，由比特币中的10分钟缩减为15秒，在提升了其确认速度和效率的同时，也产生了共识问题。</p>
<p>​    在比特币系统中，遵循着”长链优先“规则，也就是最长的主链才是比特币中合法的链，如果矿工挖出的区块，并不是沿着最长链进行的，就会产生分叉，这些区块也被称为”孤块“，其将会被认定为无用的，矿工也无法获得相应的奖励。</p>
<p>​    由于以太坊出块时间仅仅是15秒，很有可能多个矿工同时挖出了一个区块，此时占据优势算力、地理位置优越的矿池发布的区块能更快的被各个节点确认，而单个矿工的速度远远赶不上这些矿池，导致他们所挖出的块成为”孤块“，如果还继续沿用比特币的处理方式，那么这些矿工将无法获得任何奖励，再加上算力证明机制下算力的巨大投入，也带来了资源和人力的浪费。长此以往，将不仅会是算力浪费的问题，还会导致矿工怠工或者一系列的安全问题，影响到区块链的共识，因此，以太坊引入了Ghost协议，来解决这些问题。</p>
<h2 id="以最重链取代最长链"><a href="#以最重链取代最长链" class="headerlink" title="以最重链取代最长链"></a>以最重链取代最长链</h2><p>​    在以太坊的Ghost协议中，孤块并非像比特币中直接被抛弃，而是认为孤块也有一定的价值，并给予挖出孤块的矿工一定的回报，并称其为”叔块“，这不仅减少了在更短出块时间下频繁产生分差的算力浪费问题，也为主链的安全作出贡献。</p>
<p>​    与比特币不同，以太坊中的主链是最重链，而不是最长链，打包引用叔块的矿工也能够获得一定的报酬，同时也能够使主链更重，这激励了矿工去打包叔块。</p>
<h2 id="叔块如何被引用"><a href="#叔块如何被引用" class="headerlink" title="叔块如何被引用"></a>叔块如何被引用</h2><p>​    相比于引用，我认为网络上所说的”招安“更加通俗和恰当，打包叔块可以理解为主链上的大区块来”招安“叔块，避免有些矿工在分叉后不愿意合并到主链，继续在自己的分叉上挖矿，希望能够赌运气下一次比大矿池挖得更快，这样就会不利于出现分叉后的快速合并。</p>
<p>​    并非所有叔块和引用者都能得到奖励，在Ghost协议下，只有7代以内的叔块能够被招安并得到奖励，这样是为了避免有些矿工专门在之前的链上制造分叉，然后等待被招安获得奖励的情况。同时，距离主链代数越近的叔块，被招安得到的奖励也就越多，从1到7代分别为:7/8、6/8、5/8……1/8，其奖励也就 = 出块奖励 * 比例。引用者得到的奖励 = 出块奖励 + 1/32 * 出块奖励 * 打包的叔块数，每次打包的叔块数不能超过2个。</p>
<p>​    <img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/1446032-20180909110545259-1917568601.png" alt="1446032-20180909110545259-1917568601"></p>
<p>​    如图所示，主链为1、2、3、4，其他的均为叔块，假设此时3已经出块，大矿池想要将叔块与主链快速合并，就要进行招安，它可以首先选择3-1、3-2两个叔块，那么他就要讲这两个叔块的Hash值写到即将要挖出来的4号区块中，如果4号区块成功被挖出，那大矿池能够得到的奖励 = 出块奖励 * 1/32  * 2 + 出块奖励，同时挖出这两个区块的矿工能够获得的奖励 = 出块奖励 * 7/8，当3-1、3-2两个叔块的矿工发现自己被招安，且获得奖励，那么他们将有很大概率不会继续挑战大矿池的算力而选择合并，由此实现了主链的快速合并。</p>
<p>​    在准备挖第五块区块时，可以继续选择招安3-3、3-4两个叔块，但是此时的奖励比例已经变成了6/8，一直到某个叔块已经超过7代，就不会获得奖励了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wanghui-garcia/p/9607356.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanghui-garcia/p/9607356.html</a></p>
<p><a href="https://blog.csdn.net/t46414704152abc/article/details/81191804" target="_blank" rel="noopener">https://blog.csdn.net/t46414704152abc/article/details/81191804</a></p>
]]></content>
      <categories>
        <category>【学习】</category>
      </categories>
      <tags>
        <tag>【以太坊】</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS系统下运行本地以太坊源码</title>
    <url>/2020/09/19/%E5%9C%A8MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><ul>
<li>操作系统：MacOS 10.15</li>
<li>编译器：goland 2020.2.2</li>
<li>环境：Go 1.15.2</li>
</ul>
<br>

<h1 id="二、go-ethereum代码下载"><a href="#二、go-ethereum代码下载" class="headerlink" title="二、go-ethereum代码下载"></a>二、go-ethereum代码下载</h1><p>​    ethereum开源免费，可以前往<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum</a>  下载源码</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919143445539.png" alt="image-20200919143445539"></p>
<p>点击右上角绿色的Code，再点击下方的Download ZIP即可将源代码下载至本地</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919143552435.png" alt="image-20200919143552435"></p>
<br>

<h1 id="三、项目结构"><a href="#三、项目结构" class="headerlink" title="三、项目结构"></a>三、项目结构</h1><p>​    该项目对目录结构有严格的要求，如果不按其预定的目录结构进行部署，将会有一系列的编译错误：</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919143750120.png" alt="image-20200919143750120"></p>
<p>其正确的目录要求如下：</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919143853298.png" alt="image-20200919143853298"></p>
<p>1.首先先用goland创建一个新项目，这个项目名任意，我起的叫做geth，然后再其中创建三个文件夹，分别为bin、pkg以及src</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144007994.png" alt="image-20200919144007994"></p>
<p>2.然后进入src目录下创建github.com目录和golang.org目录</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144107511.png" alt="image-20200919144107511"></p>
<ol start="3">
<li><p>进入到github.com目录，创建ethereum目录</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144157891.png" alt=""></p>
</li>
<li><p>进入到ethereum目录，将刚才下好的源代码复制进去，同时将其名字改为go-ethereum</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144312938.png" alt="image-20200919144312938"></p>
</li>
</ol>
<h1 id="四、源码编译"><a href="#四、源码编译" class="headerlink" title="四、源码编译"></a>四、源码编译</h1><ol>
<li><p>用goland编译器打开刚才设置好的项目，点击最上方的Goland选项卡，点击Preferences</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144526041.png" alt="image-20200919144526041"></p>
</li>
<li><p>点击GOPATH，并将该项目加入其中</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144618530.png" alt=""></p>
</li>
<li><p>点开go-ethereum-cmd-geth-main.go文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144849725.png" alt="image-20200919144849725"></p>
</li>
<li><p>点击右上角的Edit Configurations</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919144940535.png" alt="image-20200919144940535"></p>
</li>
<li><p>如图所示修改 Name，Run kind，Directory，Output directory选项，并点击Apply，再点击Ok</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919145110549.png" alt="image-20200919145110549"></p>
</li>
<li><p>点击运行，即可通过编译，成功运行</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919145641821.png" alt="image-20200919145641821"></p>
</li>
</ol>
   <br>

<h1 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h1><p><strong>1.依赖问题，这类问题是没有下载所需的依赖包</strong></p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919145730455.png" alt="image-20200919145730455"></p>
<p>​    找到错误位置，并点击红色小灯泡 点击go get…………下载所需依赖即可，如下图这种常见的缺失的依赖包，此处已经下载完毕，所以没有报错</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919145906521.png" alt="image-20200919145906521"></p>
<p><strong>2.go: cannot find main module； see ‘go help modules‘</strong></p>
<p>解决方法很简单，打开Edit Configurations</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919150957460.png" alt="image-20200919150957460"></p>
<p>在Environment选项中加入GO111MODULE=auto即可</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200919151107158.png" alt="image-20200919151107158"></p>
]]></content>
      <categories>
        <category>【学习】</category>
      </categories>
      <tags>
        <tag>【区块链】</tag>
      </tags>
  </entry>
  <entry>
    <title>解决MacOS 10.15以上版本无法启动IDA的问题</title>
    <url>/2020/07/01/%E8%A7%A3%E5%86%B3MacOS-10-15%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8ida%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><ul>
<li><p>操作系统：MacOS 10.15以上版本</p>
</li>
<li><p>使用工具：IDA v7.0</p>
<br>

</li>
</ul>
<h1 id="二、IDA简介"><a href="#二、IDA简介" class="headerlink" title="二、IDA简介"></a>二、IDA简介</h1><p>​    IDA是IDA Pro的简称，是一款极为优秀的交互式汇编工具，也是目前最为优秀的静态反编译软件之一，具有强大的功能，但是操作十分复杂，功能众多。IDA具有交互式、可编程、可扩展、多处理器等特点，是最好的逆向工程利器之一。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200701180000231.png" alt="image-20200701180000231"></p>
<br>

<h1 id="三、解决IDA在MacOS-10-15版本上无法运行的问题"><a href="#三、解决IDA在MacOS-10-15版本上无法运行的问题" class="headerlink" title="三、解决IDA在MacOS 10.15版本上无法运行的问题"></a>三、解决IDA在MacOS 10.15版本上无法运行的问题</h1><p>​    由于10.15版本以上的Mac系统指令集的问题，IDA无法直接安装，但是如果在10.4等低版本的Mac系统上安装后，提取在/Applications文件下的文件，在10.15上打开就可以正确运行，有以下两种方式可以做到：</p>
<p>​    <strong>1.用vm虚拟机构建MacOS低版本环境，安装好IDA后，提取出来，在自己的电脑环境中运行。</strong></p>
<p>​    <strong>2.将自己的电脑系统版本退回到低版本（极不推荐）。</strong></p>
<p>​    以上两种方式都可以解决此问题，但是都有些麻烦，因此我将已经安装成功的IDA提取出来，放在网盘上，经测试可以正确使用。</p>
<p>​    下载地址：</p>
<p>​    <strong>链接:</strong> <strong><a href="https://pan.baidu.com/s/1ZBfbtQUOal3a5E0L9vOM5Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZBfbtQUOal3a5E0L9vOM5Q</a></strong>  </p>
<p>​    <strong>密码: jrik</strong></p>
<p>​    下载之后，解压，可正常使用。</p>
<br>

<h1 id="四、解决IDA-has-almost-crashed问题"><a href="#四、解决IDA-has-almost-crashed问题" class="headerlink" title="四、解决IDA has almost crashed问题"></a>四、解决IDA has almost crashed问题</h1><p>​    在使用ida时，经常会出现如下问题</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200701181159903.png" alt="image-20200701181159903"></p>
<p>​    这是由于多输入法造成的，只要在使用的时候，使用自带的默认英文状态，不使用其他输入法，就可以解决此类问题，成功启动</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200701181253112.png" alt="image-20200701181253112"></p>
<p>​    如果觉得很麻烦，可以参考此项目：<a href="https://github.com/fjh658/IDA7.0_SP" target="_blank" rel="noopener">https://github.com/fjh658/IDA7.0_SP</a></p>
<p>​    如果看不懂的话，可以下载如下链接中的内容：</p>
<p>​    <strong>链接: <a href="https://pan.baidu.com/s/1JhAeTFOZ4yxKbjN81IsTHQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1JhAeTFOZ4yxKbjN81IsTHQ</a></strong>  </p>
<p>​    <strong>密码: 4me0</strong></p>
<p>​    下载解压后，复制其中的<span style='color:red'><strong>libqcocoa.dylib</strong></span>文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200701181827977.png" alt="image-20200701181827977"></p>
<p>右键点击在应用中的IDA，选择显示包内容</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200701182001775.png" alt="image-20200701182001775"></p>
<p>依次打开Contents、PlugIns、platforms文件夹，用刚才复制的文件，替换其中的<span style='color:red'><strong>libqcocoa.dylib</strong></span>文件，之后就可以正常使用IDA了。</p>
]]></content>
      <categories>
        <category>【学习】</category>
      </categories>
      <tags>
        <tag>【工具】</tag>
        <tag>【常见问题】</tag>
      </tags>
  </entry>
  <entry>
    <title>注册码、注册机失效时用补丁破解010 editor</title>
    <url>/2020/06/30/%E6%B3%A8%E5%86%8C%E7%A0%81%E3%80%81%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%A4%B1%E6%95%88%E6%97%B6%E7%94%A8%E8%A1%A5%E4%B8%81%E7%A0%B4%E8%A7%A3010-editor/</url>
    <content><![CDATA[<h1 id="一、操作环境"><a href="#一、操作环境" class="headerlink" title="一、操作环境"></a>一、操作环境</h1><p>​    操作系统：此操作全部基于Mac OS操作系统。</p>
<p>​    软件版本：010 editor v7.0.2</p>
<br>

<h1 id="二、010-editor"><a href="#二、010-editor" class="headerlink" title="二、010 editor"></a>二、010 editor</h1><p>​    010 editor是一款极其强大，甚至可以说是最优秀的文本/十六机制编辑器，同时兼容Mac OS、Windows、Linux等操作系统，支持模版和脚本操作，可以为二进制文件定义模版，如果以后再编辑相同类型文件，可以调用模版进行自动分析，功能丰富、简单易用。</p>
<br>

<h1 id="三、注册码、注册机方式"><a href="#三、注册码、注册机方式" class="headerlink" title="三、注册码、注册机方式"></a>三、注册码、注册机方式</h1><p>​    010 editor早已经被破解，主要方式主要是注册码以及注册机两种，注册码方式如下：</p>
<p>​    百度查找通用注册码，如下图</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200630222452730.png" alt="image-20200630222452730"></p>
<p>​    将其输入至下图所示的文本框中，即完成破解</p>
<br>

<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200630223618224.png" alt="image-20200630223618224"></p>
<br>

<p>注册机方式如下：</p>
<p>​    下载如图所示的注册机，输入Name，就会得到相应的注册码</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200630224813986.png" alt="image-20200630224813986">    将得到的内容，输入到对应的文本框，即可完成破解。</p>
<br>

<h1 id="四、破解补丁方式"><a href="#四、破解补丁方式" class="headerlink" title="四、破解补丁方式"></a>四、破解补丁方式</h1><p>​    注册码、注册机方式进行破解后，很有可能会出现如图所示问题：</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/896827_F6NYZSAQ7SX54UB.png" alt="图片描述"></p>
<p>为解决此问题，可以使用破解补丁方式，绕过网络审核，从而破解软件。</p>
<p><strong>补丁下载链接：</strong></p>
<p>链接: <a href="https://pan.baidu.com/s/1oCCmK0LMxwg-VMuC9ZEX2w" target="_blank" rel="noopener">https://pan.baidu.com/s/1oCCmK0LMxwg-VMuC9ZEX2w</a><br>密码: 3968</p>
<br>

<p>将此补丁下载后，将其中的010 editor文件复制，找到你电脑应用中的010 editor,点击右键，选择显示包内容</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/896827_HTK79TDDM4V7BUY.png" alt="图片描述"></p>
<p>然后找到MacOS文件夹</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200630225416412.png" alt="image-20200630225416412"></p>
<p>并用刚才复制的010 editor文件覆盖此文件夹中的对应文件</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200630225513189.png" alt="image-20200630225513189"></p>
<p>之后可正常使用该软件。</p>
<p><img src="https://sundaohan.oss-cn-beijing.aliyuncs.com/SDHBlog/image-20200630225535473.png" alt="image-20200630225535473"></p>
]]></content>
      <categories>
        <category>【学习】</category>
      </categories>
      <tags>
        <tag>【工具】</tag>
        <tag>【破解】</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello SunDaohan</title>
    <url>/2020/06/30/Hello-SunDaohan/</url>
    <content><![CDATA[<h2 id="这是第一篇博文"><a href="#这是第一篇博文" class="headerlink" title="这是第一篇博文"></a>这是第一篇博文</h2><p>试下效果</p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
